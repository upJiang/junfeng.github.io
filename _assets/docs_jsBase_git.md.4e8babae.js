import{g as e,f as t,E as i}from"./common-d6bd45c0.js";const a='{"title":"git 的配置","frontmatter":{},"headers":[{"level":2,"title":"git 的配置","slug":"git-的配置"},{"level":2,"title":"远程仓库","slug":"远程仓库"},{"level":2,"title":"拉取代码","slug":"拉取代码"},{"level":3,"title":"从 git 仓库克隆代码","slug":"从-git-仓库克隆代码"},{"level":3,"title":"直接在文件夹上初始化并绑定远程分支","slug":"直接在文件夹上初始化并绑定远程分支"},{"level":3,"title":"在已有git版本库的项目中，想要绑定其它远程仓库","slug":"在已有git版本库的项目中，想要绑定其它远程仓库"},{"level":2,"title":"四个关键点","slug":"四个关键点"},{"level":2,"title":"HEAD","slug":"head"},{"level":2,"title":"branch(分支)","slug":"branch-分支"},{"level":3,"title":"git fetch 与 git pull 的区别","slug":"git-fetch-与-git-pull-的区别"},{"level":2,"title":"log(查看)","slug":"log-查看"},{"level":2,"title":"blame(查看文件的每个部分是谁修改的)","slug":"blame-查看文件的每个部分是谁修改的"},{"level":2,"title":"add","slug":"add"},{"level":2,"title":"commit(提交)","slug":"commit-提交"},{"level":2,"title":"stash(暂存)","slug":"stash-暂存"},{"level":2,"title":"rm(删除)","slug":"rm-删除"},{"level":2,"title":"reset(重置)","slug":"reset-重置"},{"level":3,"title":"找回reset掉的代码","slug":"找回reset掉的代码"},{"level":3,"title":"git fsck","slug":"git-fsck"},{"level":3,"title":"reset总结","slug":"reset总结"},{"level":2,"title":"revert(撤销)","slug":"revert-撤销"},{"level":3,"title":"reset 跟 revert 的区别","slug":"reset-跟-revert-的区别"},{"level":2,"title":"rebase(变基)","slug":"rebase-变基"},{"level":3,"title":"合并","slug":"合并"},{"level":2,"title":"merge","slug":"merge"},{"level":2,"title":"cherry-pick","slug":"cherry-pick"},{"level":2,"title":"tag(标签)","slug":"tag-标签"},{"level":2,"title":".gitignore","slug":"gitignore"},{"level":2,"title":".gitkeep","slug":"gitkeep"}],"relativePath":"docs/jsBase/git.md","lastUpdated":1639657876238.9192}';var r={};const n=i('<h2 id="git-的配置"><a class="header-anchor" href="#git-的配置" aria-hidden="true">#</a> git 的配置</h2><p>1.下载 Git <a href="https://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">下载地址</a></p><p>2.生成 ssh 秘钥：打开终端，执行 ssh-keygen -t rsa -C &quot;邮箱地址&quot;，切换到～/.shh目录中，复制 id_rsa.pub 的内容到你 gitlab/gitee/github 等的 ssh key 中。</p><p>3.配置 git 的用户名和邮箱</p><div class="language-"><pre><code># 全局配置\n$ git config --global user.name &quot;xxx&quot;\n$ git config --global user.email &quot;xxx@xx.com&quot;\n\n# 在当前项目下，单独配置\n$ git config user.name &quot;xxx&quot;\n$ git config user.email &quot;xxx@xx.com&quot;\n</code></pre></div><p><strong>查询配置信息</strong></p><div class="language-"><pre><code># 列出当前配置\n$ git config --list\n\n# 列出repository配置\n$ git config --local --list\n\n# 列出全局配置\n$ git config --global --list\n\n# 列出系统配置\n$ git config --system --list\n</code></pre></div><h2 id="远程仓库"><a class="header-anchor" href="#远程仓库" aria-hidden="true">#</a> 远程仓库</h2><blockquote><p>配置完后我们第一步应该理解远程仓库这个概念，远程仓库就是我们在 gitlab/github 这些地方的代码仓库。我们一般一个项目只对应一个远程仓库，远程仓库名默认为 origin，我们可以使用 rename 命令对它进行重命名，如果只需要对应一个远程仓库，不建议更改名字，一个项目也可以对应多个远程仓库。</p></blockquote><h4 id="查看"><a class="header-anchor" href="#查看" aria-hidden="true">#</a> 查看</h4><div class="language-"><pre><code># 查看当前配置有哪些远程仓库\n$ git remote\norigin\n\n# 执行时加上 -v 参数，可以看到每个别名的实际链接地址。\n$ git remote -v\norigin    git@github.com:xxx1.git (fetch)\norigin    git@github.com:xxx1.git (push)\n\n# 查看git的配置信息,可以看到本地分支跟远程分支的关联信息\n$ git remote show origin\n\n  remote origin\n  Fetch URL: https://git.vankeservice.com/v0840985/jiang.git\n  Push  URL: https://git.vankeservice.com/v0840985/jiang.git\n  HEAD branch: master\n  Remote branch:\n    master tracked\n  Local branches configured for &#39;git pull&#39;:\n    master merges with remote master\n    test   merges with remote master\n  Local ref configured for &#39;git push&#39;:\n    master pushes to master (fast-forwardable)\n</code></pre></div><h4 id="添加删除"><a class="header-anchor" href="#添加删除" aria-hidden="true">#</a> 添加删除</h4><div class="language-"><pre><code># 添加一个叫ogigin2的远程仓库\n$ git remote add origin2 git@github.com:xxx2.git\n$ git remote -v\norigin    git@github.com:xxx1.git (fetch)\norigin    git@github.com:xxx1.git (push)\norigin2    git@github.com:xxx2.git (fetch)\norigin2    git@github.com:xxx2.git (push)\n\n# 删除远程仓库 origin2\n$ git remote rm origin2\n$ git remote -v\norigin    git@github.com:xxx1.git (fetch)\norigin    git@github.com:xxx1.git (push)\n</code></pre></div><h4 id="修改名字-本地对于远程仓库的别名"><a class="header-anchor" href="#修改名字-本地对于远程仓库的别名" aria-hidden="true">#</a> 修改名字(本地对于远程仓库的别名)</h4><div class="language-"><pre><code>git remote rename old_origin_name new_origin_name\n</code></pre></div><h4 id="绑定-本地分支并和远程分支"><a class="header-anchor" href="#绑定-本地分支并和远程分支" aria-hidden="true">#</a> 绑定(本地分支并和远程分支)</h4><div class="language-"><pre><code># 1. 拉取远程仓库代码\n$ git fetch origin 拉取所有 \n$ git fetch origin test 拉取指定分支\n\n# 2. 切换到指定分支\n$ git checkout test 会自动在已有的远程分支上去检测，找不到会报错\n找到了：\nBranch &#39;test&#39; set up to track remote branch &#39;test&#39; from &#39;origin&#39;.\nSwitched to a new branch &#39;test&#39;\n找不到：\nerror: pathspec &#39;test&#39; did not match any file(s) known to git\n$ git checkout -b test 在本地创建test分支并将工作目录切换到此分支\n\n# 3. 将本地分支跟远程分支绑定,-u 就是--set-upstream，绑定后之后操作就不需要指定仓库跟分支了\n$ git branch -u origin/test\n$ git push -u origin/test\n</code></pre></div><h2 id="拉取代码"><a class="header-anchor" href="#拉取代码" aria-hidden="true">#</a> 拉取代码</h2><blockquote><p>最近在网上有个真实发生的案例比较火，说的是一个新入职的员工，不会用 Git 拉代码，第二天就被开掉了。<br>那么刚进公司，同事给了你git仓库地址，你这时候应该怎么做呢？ 拉取代码时会有两种方式: https、ssh</p></blockquote><ul><li>https 需要每次提交前都手动输入用户名和密码，<br></li><li>ssh 的方式配置完毕后 Git 都会使用你本地的私钥和远程仓库的公钥进行验证是否是一对秘钥，从而简化了操作流程。</li></ul><h3 id="从-git-仓库克隆代码"><a class="header-anchor" href="#从-git-仓库克隆代码" aria-hidden="true">#</a> 从 git 仓库克隆代码</h3><blockquote><p>clone都会包含所有远程分支的代码，可以通过 checkout 切换分支，clone 过来的代码不需要初始化就可以直接操作分支了</p></blockquote><div class="language-"><pre><code># 在本地生成默认分支，一般是master或者main\n$ git clone git@github.com:xxx.git\n\n# 在本地生成指定分支\n$ git clone -b test git clone git@github.com:xxx.git\n</code></pre></div><h3 id="直接在文件夹上初始化并绑定远程分支"><a class="header-anchor" href="#直接在文件夹上初始化并绑定远程分支" aria-hidden="true">#</a> 直接在文件夹上初始化并绑定远程分支</h3><div class="language-"><pre><code>$ cd 文件夹\n$ git init\n$ git remote add origin git clone git@github.com:xxx.git //添加远程仓库\n$ git branch -u origin/test //绑定远程分支,或者git push -u origin/test\n</code></pre></div><h3 id="在已有git版本库的项目中，想要绑定其它远程仓库"><a class="header-anchor" href="#在已有git版本库的项目中，想要绑定其它远程仓库" aria-hidden="true">#</a> 在已有git版本库的项目中，想要绑定其它远程仓库</h3><div class="language-"><pre><code>$ cd existing_repo\ngit remote add other_origin git clone git@github.com:xxx.git //克隆并添加其它远程仓库代码,\ngit push -u other_origin --all  //提交所有代码\ngit push -u other_origin --tags //提交所有的标签\n</code></pre></div><p>注意：如果你还想用已有仓库的名字，请删除已有本地仓库或者修改已有本地仓库名</p><div class="language-"><pre><code>git remote rm origin\ngit remote rename origin new_origin\n</code></pre></div><p><strong>那么至此，git 的初始化基础已经掌握了，接下来该学习一些常用的操作命令</strong></p><h2 id="四个关键点"><a class="header-anchor" href="#四个关键点" aria-hidden="true">#</a> 四个关键点</h2><p>git 的通用操作流程图 <a data-fancybox title="" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/513f0456d26a46808e72fcb40bdaff2a~tplv-k3u1fbpfcp-zoom-1.image"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/513f0456d26a46808e72fcb40bdaff2a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></a></p><p>1.<strong>工作区(workspace)</strong>：就是你平时写代码的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作</p><p>2.<strong>暂存区（Index/Stage）</strong>：就是我们使用 <code>git add</code> 提交的区域，在这里我们可以选择提交或者放弃哪些更改</p><p>3.<strong>本地仓库(repository)</strong>：本地仓库，位于自己的电脑上，通过 <code>git commit</code> 提交暂存区的内容，会进入本地仓库</p><p>4.<strong>远程仓库(remote)</strong>：git 远程仓库，gitlab/gitee/github/svn 等等，通过<code>git push</code>提交远程仓库</p><p>总结：平时在工作区正常开发，通过 git add 提交代码到暂存区，通过 git commit 提交代码到本地仓库，通过 git push 提交代码到远程仓库</p><h2 id="head"><a class="header-anchor" href="#head" aria-hidden="true">#</a> HEAD</h2><blockquote><p>我们先来理解 HEAD、HEAD^、commit_id 这些东西的概念</p></blockquote><p>git 必须知道当前版本是哪个版本，在git中会有很多commit_id，<code>HEAD</code> 就是当前版本的commit_id，也就是最新的提交 <code>3628164...882e1e0</code> ，可以用前七位缩写，上一个版本就是 <code>HEAD^</code> ，上上一个版本就是 <code>HEAD^^</code> ，当然往上100个版本写100个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code>。</p><h4 id="符号操作"><a class="header-anchor" href="#符号操作" aria-hidden="true">#</a> 符号操作</h4><p>git 中的一些连续commit_id 都是左开右闭的<code>3628164...882e1e0</code>，如果想左闭右闭合就在开始的commit加上^ <code>3628164^...882e1e0</code></p><p>n 默认是 1 不写，直接 HEAD 就是当前指针<br><strong>HEAD^n</strong> 后退 n 步,不管父子顺序的提交，意思就是不需要管是不是同一个分支的提交<br><strong>HEAD~n</strong> 退到第 n 个父提交,按照提交的父子顺序，意思就是必须是同一个分支的提交</p><p>HEAD～n 等于 HEAD~~~( n 个波浪) 等于 HEAD^^^(n个尖括号)</p><p>HEAD^n 比较特殊，不需要管是不是同一个分支的提交</p><p>比如我们有四个分支，分支树形图如下： <a data-fancybox title="截屏2021-11-15 上午11.18.53.png" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa7b95dac93b4146be0261ebd4ee83fc~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa7b95dac93b4146be0261ebd4ee83fc~tplv-k3u1fbpfcp-watermark.image?" alt="截屏2021-11-15 上午11.18.53.png"></a></p><div class="language-"><pre><code>albert@home-pc MINGW64 /d/gitstart (dev1)\n$ git rev-parse --short HEAD~~ //退到第二个父提交\ndcdcb87\n\nalbert@home-pc MINGW64 /d/gitstart (dev1)\n$ git rev-parse --short HEAD^^ //表示退一步到第一个父提交上，在退一步到第一个父提交上\ndcdcb87 \n\nalbert@home-pc MINGW64 /d/gitstart (dev1)\n$ git rev-parse --short HEAD~2 //退到第二个父提交\ndcdcb87\n\nalbert@home-pc MINGW64 /d/gitstart (dev1)\n$ git rev-parse --short HEAD^2 //后退两步，不管父子顺序的提交\ne330eac\n</code></pre></div><p>只要你 commit 了，就算没有 push ，也会生成 commit_id ，HEAD 就会移动到你最新的 commit 上</p><p>我们可以通过 git log、git reflog 查看提交记录，以及当前 HEAD</p><p>HEAD^ 当前的上一个 HEAD~1</p><p><strong>git rev-parse</strong> 获取完整 commit_id、查看当前分支</p><div class="language-"><pre><code># 获取当前分支名\n$ git rev-parse --abbrev-ref HEAD\ntest\n\n# 获取当前HEAD/完整的commit_id\n$ git rev-parse HEAD / git rev-parse d63ac5c\nd63ac5c21ef604812ae38c9807e16d59b62b19d7\n\n# 获取当前HEAD/短的commit_id\n$ git rev-parse --short HEAD /git rev-parse d63ac5c21ef604812ae38c9807e16d59b62b19d7\nd63ac5c\nd63ac5c\n</code></pre></div><h2 id="branch-分支"><a class="header-anchor" href="#branch-分支" aria-hidden="true">#</a> branch(分支)</h2><div class="language-"><pre><code># 创建本地分支\n$ git branch 分支名\n\n# 切换分支\n$ git checkout 分支名\n\n# 创建分支并切换到分支\n$ git branch -b 分支名\n\n# 删除本地分支\n$ git branch -d 分支名\n\n# 删除远程分支\n$ git push origin --d 远程分支名\n\n# 合并分支\n$ git merge 本地分支名\n$ git merge origin/master\n\n# 在远程分支的基础上创建本地分支,这个很常用\n$ git checkout -b test origin/master\n</code></pre></div><p><strong>在远程分支的基础上创建本地分支,这个很常用</strong></p><div class="language-"><pre><code>$ git checkout -b test origin/master\n\n# 拆分\n$ git branch test\n$ git checkout test \n$ git fetch --all //拉取远程所有分支的最新代码，但不合并\n$ git reset --hard origin/master //将当前分支内容重置成远程分支内容，reset后面有详细介绍\n</code></pre></div><h3 id="git-fetch-与-git-pull-的区别"><a class="header-anchor" href="#git-fetch-与-git-pull-的区别" aria-hidden="true">#</a> git fetch 与 git pull 的区别</h3><p>都是拉取远程代码，它们的区别是 fetch 不会自动合并工作区代码，<strong>fetch + merge === git pull</strong>。</p><div class="language-"><pre><code># 拉取当前分支的最新内容\n$ git fetch/pull\n\n# 拉取所有分支的最新内容\n$ git fetch/pull --all\n\n# 拉取指定分支，之后执行git fetch 会默认拉取该分支,之后如果想拉取所有分支，需要加 --all参数\n$ git fetch/pull origin 分支名\n</code></pre></div><p><strong>git pull 拉取不到最新代码?</strong><br> 大概率是本地分支并未与远程分支建立连接</p><div class="language-"><pre><code># 先查看git的配置信息,可以看到本地分支跟远程分支的关联信息\n$ git remote show origin\n\n  remote origin\n  Fetch URL: https://git.vankeservice.com/v0840985/jiang.git\n  Push  URL: https://git.vankeservice.com/v0840985/jiang.git\n  HEAD branch: master\n  Remote branch:\n    master tracked\n  Local branches configured for &#39;git pull&#39;:\n    master merges with remote master\n    test   merges with remote master\n  Local ref configured for &#39;git push&#39;:\n    master pushes to master (fast-forwardable)\n</code></pre></div><p>如果关联错误，那么就绑定一下即可</p><div class="language-"><pre><code>git branch -u origin/test\n</code></pre></div><h2 id="log-查看"><a class="header-anchor" href="#log-查看" aria-hidden="true">#</a> log(查看)</h2><p>查看提交历史：git log 显示所有提交过的版本信息，当前 HEAD，不包括已经被删除的 commit 记录和 reset 的操作</p><p><strong>git默认展示三条log信息，按S键可以往下展开哦</strong></p><div class="language-"><pre><code>commit 7b1e2c6bd3851732d0d3e1d01169cd31042b64bc (HEAD -&gt; fix/coupon, origin/fix/coupon)\nAuthor: libinbin &lt;libinbin@ainirobot.com&gt;\nDate:   Sat May 19 17:26:33 2018 +0800\n    第三次commit\n\ncommit 004ff75d9ccf27b6721f6b6ea86efa92319f4102\nAuthor: libinbin &lt;libinbin@ainirobot.com&gt;\nDate:   Sat May 19 17:08:15 2018 +0800\n    第一次commit\n</code></pre></div><p><a href="https://blog.csdn.net/m0_50668851/article/details/108651417" target="_blank" rel="noopener noreferrer">git log 的更多参数</a></p><p>查看所有分支的操作记录：git reflog 包括 reset 掉的记录</p><div class="language-"><pre><code>2e39ab1 HEAD@{15}: commit (merge): feat: d\n750cf0d HEAD@{16}: commit: feat: f\nc5af345 HEAD@{17}: commit (merge): feat: update\n062055c HEAD@{18}: checkout: moving from main to test\nfb2af28 HEAD@{19}: commit: feat: update\n</code></pre></div><p><a href="https://blog.csdn.net/chaiyu2002/article/details/81773041" target="_blank" rel="noopener noreferrer">git reflog 的更多参数</a></p><h2 id="blame-查看文件的每个部分是谁修改的"><a class="header-anchor" href="#blame-查看文件的每个部分是谁修改的" aria-hidden="true">#</a> blame(查看文件的每个部分是谁修改的)</h2><div class="language-"><pre><code>$ git blame .editorconfig\n\n^b818b09 (某某某            2019-05-20 18:08:43 +0800  1) # http://editorconfig.org\n^b818b09 (某某某            2019-05-20 18:08:43 +0800  2) root = true\n^b818b09 (某某某            2019-05-20 18:08:43 +0800  3) \n00000000 (Not Committed Yet 2021-11-11 20:07:38 +0800 13) sda\n</code></pre></div><h2 id="add"><a class="header-anchor" href="#add" aria-hidden="true">#</a> add</h2><div class="language-"><pre><code># 提交工作区所有文件到暂存区\n$ git add .\n\n# 提交所有被删除和修改的文件到数据暂存区\n$ git add -u &lt;==&gt; git add –update\n\n# 提交所有被删除、被替换、被修改和新增的文件到数据暂存区\n# git add -A &lt;==&gt;git add –all\n\n# 提交工作区中指定文件/文件夹名到暂存区\n$ git add .editorconfig(文件名) src/pages/index.js(有相同名字使用路径) page(文件夹名)\n</code></pre></div><h2 id="commit-提交"><a class="header-anchor" href="#commit-提交" aria-hidden="true">#</a> commit(提交)</h2><div class="language-"><pre><code># 工作区中有更改的内容，正常提交\n$ git commit -m &quot;提交信息&quot;\n\n# 将add操作合并一起执行\n$ git commit -a -m &quot;提交信息&quot;\n</code></pre></div><p><strong>修改上一次的提交信息，commit_id 会重置，在日志看不到这个操作记录</strong></p><div class="language-"><pre><code>$ git commit --amend\n进入vim，输入i进入编辑，在首行修改提交信息，esc退出编辑后，按shift+: 键入 :wq 回车退出并保存\n\n cccc   //输入i进入编辑，在首行修改提交信息\n\n Please enter the commit message for your changes. Lines starting\n with &#39;#&#39; will be ignored, and an empty message aborts the commit.\n\n Date:      Fri Nov 12 15:48:37 2021 +0800\n\n On branch master\n Your branch is ahead of &#39;origin/master&#39; by 3 commits.\n   (use &quot;git push&quot; to publish your local commits)\n\n Changes to be committed:\n       new file:   test2.js\n</code></pre></div><p><strong>修改前 n 次 commit 的提交信息,使用 rebase，后面会详细介绍 rebase</strong></p><div class="language-"><pre><code>$ git rebase -i  //-i是指使用vim编辑，此时会进入vim编辑\n\npick caf7ca7 aaaaa\npick b093fc3 bbbb\npick d52ce82 ggg\n</code></pre></div><p>先明白这三个区别：<br> pick：保留该 commit（缩写:p）<br> reword：保留该 commit，但我需要修改该 commit 的注释（缩写:r）<br> edit：保留该 commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写: e）</p><p>将第三条改成 reword 或者 edit ，保存退出</p><p>reword d52ce82 ggg <br> 保存退出后会直接进入到下一个vim进行编辑，其实就是执行 git commit --amend 后的编辑界面，正常修改保存后提交即可</p><p>edit d52ce82 ggg <br> 保存退出后，会让我们选择执行的下一个命令， git commit --amend 或者是 git rebase --continue，输入git commit --amend 就跟上面一样了， git rebase --continue 则退出此次更改</p><h2 id="stash-暂存"><a class="header-anchor" href="#stash-暂存" aria-hidden="true">#</a> stash(暂存)</h2><blockquote><p>当我们在开发项目的时候，假设现在你在 A 分支写代码，产品经理突然过来让你改 B 分支的 bug ，这个时候你怎么办？<br>我们知道只有把工作区的代码都 commit上去之后才能切换分支干活，可是你现在改的内容你并不想 commit 上去生成一条无用的 commit ，那么这时候 stash 就能够帮你解决这个问题了。stash 能够帮我们暂存我们修改的内容，之后再取出来使用，这样就不用 commit 上去了。</p></blockquote><p>暂存工作区的内容，注意一定要有改动才行，如果经常使用暂存功能，请务必添加说明信息，避免忘记是哪条切换不回来</p><div class="language-"><pre><code>$ git stash / git stash save &#39;说明信息&#39;\nSaved working directory and index state WIP on master: ad6dd27 kkkkk\n</code></pre></div><p>查看所有暂存的记录：stash@{0} 之后通过 index 去应用暂存</p><div class="language-"><pre><code>$ git stash list\nstash@{0}: WIP on master: ad6dd27 kkkkk\nstash@{1}: WIP on master: d52ce82 ggg\n</code></pre></div><p>查看暂存记录的详情</p><div class="language-"><pre><code>$ git stash show 0\n test.js | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre></div><p>应用暂存（暂存记录仍在）,先查看暂存记录跟详情，再通过index去应用<br><strong>注意：如果暂存的文件跟当前修改的文件相同，那么要想清楚再使用，可以先把当前修改 commit 上去，然后再通过 commit_id 使用 rebase/merge 合并回来</strong></p><div class="language-"><pre><code># 应用最新暂存\n$ git stash apply\n\n# 应用指定的暂存\n$ git stash apply 1\n</code></pre></div><p>清除暂存</p><div class="language-"><pre><code># 移除指定的暂存\n$ git stash drop 0\n\n# 应用暂存并将其清除\n$ git stash pop 0\n</code></pre></div><p>注：不加 stash{0} 都是操作最新的一次（栈顶）暂存, stash{0} 就是数字而已，网上很多教程使用 stash@{0}，我在实际操作中都不生效，只需要在后直接加 index 即可。<br></p><p>在实际工作中用到最多的应该是：保存暂存 git stash save &#39;说明信息&#39;，然后切换分支去做别的事情，然后切回来把保存的暂存应用并删除 git stash pop</p><h2 id="rm-删除"><a class="header-anchor" href="#rm-删除" aria-hidden="true">#</a> rm(删除)</h2><blockquote><p>跟 git reset HEAD file.js 有点类似，但 reset 会改变本地仓库，而 rm 不会，rm 只操作工作区跟暂存区，同名使用路径</p></blockquote><div class="language-"><pre><code># 仅从暂存区中删除文件，但是工作区依然还有该文件,\n$ git rm --cached file.js\n\n# 删除工作区文件，并且也从暂存区删除对应文件的记录\n$ git rm file.js  //如果报错加-f参数\n</code></pre></div><h2 id="reset-重置"><a class="header-anchor" href="#reset-重置" aria-hidden="true">#</a> reset(重置)</h2><p>git reset --mixed (默认) HEAD (默认当前 HEAD，指定某个 HEAD ) brach (分支)</p><p>reset有三种模式 <strong>soft mixed（默认） hard</strong> 注意看图示红色线条部分</p><p><a data-fancybox title="image.png" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b34c28f1284943eda41526b32109590d~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b34c28f1284943eda41526b32109590d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><ul><li>soft 让本地仓库与 Reset 节点的內容相同，那么我们的工作区代码就会跟本地仓库产生差异，会将这些差异放到暂存区中<br></li><li>mixed 让本地仓库以及暂存区跟Reset节点的內容相同，也就是会清空暂存区，但是工作区跟 soft 一样不变，我们后面可能需要重新 add <br></li><li>hard 改变工作区、暂存区、本地仓库,全部内容都变成 Reset 节点的內容相同，所以慎用，另外两个不会改变工作区内容可以把代码找回，这个用了就有点麻烦了，下面会介绍如何把 reset 掉的代码找回来</li></ul><div class="language-"><pre><code># 先查看暂存区都更改了哪些文件\n$ git status\nOn branch fix/coupon\nYour branch is up to date with &#39;origin/fix/coupon&#39;.\n//这里是放进暂存区的文件更改\nChanges to be committed:\n  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)\n        modified:   src/pages/details/index.js\n        modified:   src/pages/details/status/index.js\n        \n//这里是工作区的文件更改\nChanges not staged for commit:\n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)\n  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)\n        modified:   src/pages/details/index.js\n        modified:   src/pages/details/status/index.js\n\nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n        \n# 取消暂存区所有暂存的文件\n$ git reset  //默认mixed\n//执行后会将暂存区更改清空，变成了工作区的更改\nOn branch fix/coupon\nYour branch is up to date with &#39;origin/fix/coupon&#39;.\n\n//这里是工作区的文件更改，modified 是红色字体\nChanges not staged for commit:\n  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)\n  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)\n        modified:   src/pages/details/index.js\n        modified:   src/pages/details/status/index.js\n\nno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)\n\n# 取消暂存区已经暂存的文件\n如果暂存区中有相同名字的文件，那么文件名需要填写整个路径\n$ git reset HEAD .editorconfig\n$ git reset HEAD src/pages/details/index.js\n</code></pre></div><h3 id="找回reset掉的代码"><a class="header-anchor" href="#找回reset掉的代码" aria-hidden="true">#</a> 找回reset掉的代码</h3><ul><li>已 commit ：git reflog 获取hash值 然后 git reset --hard [对应的值]</li><li>未 commit 但 add ：git fsck --lost-found 恢复删除文件 然后到 .git/lost-found 目录寻找文件/或者通过 merge/rebase 合并回来</li><li>未 commit 未 add ：无解，所以要慎用此命令</li></ul><h3 id="git-fsck"><a class="header-anchor" href="#git-fsck" aria-hidden="true">#</a> git fsck</h3><blockquote><p><code>fill system check</code> 文件系统检查，用来对本地和远程仓库的一致性检查，<code>dangling objects</code> 悬空对象。git 中把 commit 删了后，并不是真正的删除，而是变成了悬空对象（dangling commit）。<br>git gc 在达到一定条件下会清除这些悬空对象,在悬空对象列表中，使用 <code>git show commitId</code> 查看悬空记录的详情，<code>git merge commitId</code> 即可恢复</p></blockquote><p><strong>为什么会产生悬空对象？</strong><br> 比如我们刚刚在工作区提交了一些 commit ，我们通过 reset 把这些 commit 清空掉了，这些被清空掉的 commit 就变成了 dangling commit 。又或者是比如 B commit 依靠 A commit ,而A被删掉了，那么B就悬空了</p><p><strong>Dangling blob</strong>=对暂存区域/索引所做的更改，但从未提交。Git 的一个令人惊奇的地方是，一旦它被添加到暂存区域中，就可以始终得到它，因为这些 BLOB 的行为就像提交，因为它们也有一个散列！！</p><div class="language-"><pre><code>$ git show edbfa48d1c6428d00af9b2cf6dc70a423d6969ad\n\n# http://editorconfig.org\nroot = true\n\n[*]\nindent_style = space\nindent_size = 2\ncharset = utf-8\ntrim_trailing_whitespace = true\ninsert_final_newline = true\n\n[*.md]\ntrim_trailing_whitespace = false\nsda\n</code></pre></div><p><strong>Dangling commit</strong>=未直接或由其任何优势者链接到任何分支或标记的提交。你也可以把这些拿回来！</p><div class="language-"><pre><code>$ git show e08b6bd66efe7a3842531282596c2ee8d6dd00e9  \ncommit e08b6bd66efe7a3842531282596c2ee8d6dd00e9 (origin/test, test)\nMerge: 2577fcd 216bfb3\nAuthor: 易亮亮 &lt;yill01@vanke.com&gt;\nDate:   Wed Nov 10 14:10:36 2021 +0800\n\n    Merge branch &#39;feature/newDeposit&#39; into &#39;test&#39;\n    \n    feat: 修改锁定\n    \n    See merge request CS/front/pretty-home!152\n</code></pre></div><p>git fsck --lost-found：</p><div class="language-"><pre><code># 找出所有的悬空对象,包括未被引用的，我们这种只add了，但是没有commit信息的就要添加--lost-found参数找出（更多参数自己去了解）\n$ git fsck --lost-found\ndangling commit e08b6bd66efe7a3842531282596c2ee8d6dd00e9\ndangling commit dbd5b7e3ede83289ad64c62196d82baa81ec1a2d\ndangling blob f229c0c7c6d821881e58de143d733a4d93febaa5\n\n# 通过show查看信息是不是丢失的commit\n$ git show dbd5b7e3ede83289ad64c62196d82baa81ec1a2d\n\n# 通过merge/rebase合并commit\n$ git merge dbd5b7e3ede83289ad64c62196d82baa81ec1a2d\n</code></pre></div><h3 id="reset总结"><a class="header-anchor" href="#reset总结" aria-hidden="true">#</a> reset总结</h3><p>reset 的本质：移动 HEAD 以及它所指向的 branch，<strong>reset</strong> 这个指令虽然可以用来撤销 <strong>commit</strong> ，但它的实质行为并不是撤销，而是移动 <strong>HEAD</strong> ，并且「捎带」上 <strong>HEAD</strong> 所指向的 <strong>branch</strong>（如果有的话）。</p><p><a data-fancybox title="image.png" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6398f96068734296ad3d9e15715e558d~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6398f96068734296ad3d9e15715e558d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><h2 id="revert-撤销"><a class="header-anchor" href="#revert-撤销" aria-hidden="true">#</a> revert(撤销)</h2><p>撤销<code>某些</code> commit，并且把这次撤销，作为一次<code>最新</code>的提交,需要填写提交注释，会有 revert 信息。撤销的 commit 记录仍在，只是<code>追加</code>一个 commit ，撤销后产生的新节点代码有可能会跟上一个版本的代码产生<code>冲突</code></p><p>比如说有A-B-C，使用revert b-c将代码回到 A，此时会变成 A-B-C-D，使用 reset A会变成A</p><div class="language-"><pre><code>$ git revert b093fc3f062924339f43cbc93df9497fa1eb3ff6\n\n//必须把工作区以及暂存区的更改都提交后才能操作\nerror: your local changes would be overwritten by revert.\nhint: commit your changes or stash them to proceed.\nfatal: revert failed\n\n//有冲突，解决完冲突提交\nAuto-merging test.js\nCONFLICT (content): Merge conflict in test.js\nerror: could not revert b093fc3... bbbb\nhint: after resolving the conflicts, mark the corrected paths\nhint: with &#39;git add &lt;paths&gt;&#39; or &#39;git rm &lt;paths&gt;&#39;\nhint: and commit the result with &#39;git commit&#39;\n\n//填写 commit 信息，成功提交 revert\nRevert &quot;Revert &quot;bbbb&quot;&quot;\nThis reverts commit 07bbb462cea34592ec386d19bca0309a499f3e3f.\n# Please enter the commit message for your changes. Lines starting\n# with &#39;#&#39; will be ignored, and an empty message aborts the commit.\n#\n# On branch test\n# Your branch is ahead of &#39;origin/master&#39; by 7 commits.\n#   (use &quot;git push&quot; to publish your local commits)\n#\n# Changes to be committed:\n#       modified:   test.js\n\n[test 57b7832] Revert &quot;Revert &quot;bbbb&quot;&quot;\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n# 成功后查看log\n$ git log\n//revert 变成了当前 HEAD，并且带有 commit 信息\ncommit 07bbb462cea34592ec386d19bca0309a499f3e3f (HEAD -&gt; test)\nAuthor: jiang\nDate:   Mon Nov 15 14:27:10 2021 +0800\n    Revert &quot;bbbb&quot;\n   \n    This reverts commit b093fc3f062924339f43cbc93df9497fa1eb3ff6.\n</code></pre></div><h3 id="reset-跟-revert-的区别"><a class="header-anchor" href="#reset-跟-revert-的区别" aria-hidden="true">#</a> reset 跟 revert 的区别</h3><ul><li><p>在操作上，revert 必须处理完工作区跟暂存区的变更，才能使用，并且改变的是本地仓库的代码，并且会跟前面的提交产生冲突，revert 的 HEAD 参数可以是一个 commit 范围；而 reset 不需要处理工作区跟暂存区的变更， reset 提供三种模式，reset 的 HEAD 参数只能是一个指定的 commit</p></li><li><p>在结果上，revert 是撤销 n 个 commit ，然后生成一个新 commit ，撤销掉的 commit 仍在，reset 是直接把指针往前移动到某个 commit，并且不会生成新的 commit 信息，撤销掉的 commit 就没了</p></li><li><p>在影响上，影响就在于这个撤销掉的 commit 在不在，因为 reset 会把撤销 commit 丢失，这个时候，如果有另一个人在分支提交了代码，而你的 commit 不见了，这个时候如果你强制 push 会把别人的代码冲掉了，如果你去 merge 又会把你不想要的代码给弄回来了，然后你就只能手动去弄了。但是 revert 并不会删除 commit，当你去 merge 别人代码时，你的 commit 仍在，那么 git 仍然会以你的为准。</p></li></ul><p>总结：如果你想要撤销的代码已经在远程上了，如果不存在会有人在你的分支上去提交代码，那么你可以选择 reset + 强制推送，如果有可能会有人在你的分支上去提交代码，那么就会产生问题，这个时候建议使用 revert。</p><h1 id="reset-或者-revert-后强制提交本地代码上去"><a class="header-anchor" href="#reset-或者-revert-后强制提交本地代码上去" aria-hidden="true">#</a> reset 或者 revert 后强制提交本地代码上去</h1><div class="language-"><pre><code>$ git push -f origin 远程分支名\n</code></pre></div><h2 id="rebase-变基"><a class="header-anchor" href="#rebase-变基" aria-hidden="true">#</a> rebase(变基)</h2><blockquote><p>rebse 翻译为变基，就是能够改变基点，在合并分支的时候能够改变当前分支基点，保证当前 HEAD 不变，并且提交记录是线性的。除此之外还能对某一段线性提交历史进行编辑、删除、复制、粘贴。合理使用 rebase 命令可以使我们的提交历史干净、简洁！</p></blockquote><h3 id="合并"><a class="header-anchor" href="#合并" aria-hidden="true">#</a> 合并</h3><p><a data-fancybox title="image.png" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c241190f28b04b739b23de00b1b85154~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c241190f28b04b739b23de00b1b85154~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p>场景：现在有 master 跟 Feature 两个分支，Feature 是在 master 基础上拉出来的，它们的共同基点都是白色部分，Feature 做了三次 commit，master 做了两次 commit。现在在 Feature 上需要合并 master</p><p>使用git rebase master 命令后，以它们的共同基点作为起点，先逐个应用 master 分支的更改，以 master 分支最后的提交作为基点，再逐个应用 Feature 分支的每个更改。看到这里你应该理解为什么要翻译成变基了吧，基点被改变了，并且你当前分支的HEAD仍旧没被破坏，还是线性的，是不是很棒。如果使用 merge 则会多出一个 commit</p><p><code>git merge</code> 在不是 fast-forward（快速合并）的情况下，会产生一条额外的合并记录，类似 <code>Merge branch &#39;xxx&#39; into &#39;xxx&#39;</code> 的一条提交信息 <a data-fancybox title="image.png" href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5abd099ebda04c3d9c2d6b048ad217e3~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5abd099ebda04c3d9c2d6b048ad217e3~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p>rebase 的过程中会产生<code>冲突</code>的，此时，就需要手动解决冲突，然后使用依次 <code>git add </code>、<code>git rebase --continue </code>的方式来处理冲突，完成 rebase 的过程，如果不想要某次 rebase 的结果，那么需要使用 <code>git rebase --skip </code>来跳过这次 rebase 操作。</p><blockquote><p>特别注意，只能在自己使用的 feature 分支上进行 rebase 操作，不允许在集成分支上进行 rebase，因为这种操作会修改集成分支的历史记录。</p></blockquote><h4 id="交互模式"><a class="header-anchor" href="#交互模式" aria-hidden="true">#</a> 交互模式</h4><ul><li>在开发时，我们可能会有多个 commit，这个时候 push 的时候会产生多个 commit 信息，使用 rebase 可以将多个 commit 合并成一个</li><li>合并分支的时候好会产生一条 merge 的 commit 信息。使用 rebase 不会产生 merge 的 commit 信息</li></ul><blockquote><p>比如说现在有三个本地 commit 还未 push，aa , bb ,cc，使用之前需要将工作区代码都 commit 掉。base-commit 就是指明操作的基点提交对象，基于这个基点进行 rebase 的操作，但是操作的对象<strong>不包括这个commit</strong></p></blockquote><div class="language-"><pre><code>git rebase -i &lt;base-commit &gt;\n</code></pre></div><div class="language-"><pre><code>pick：保留该commit（缩写:p）\nreword：保留该commit，但我需要修改该commit的注释（缩写:r）\nedit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）\nsquash：将该commit和前一个commit合并（缩写:s）\nfixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）\nexec：执行shell命令（缩写:x）\ndrop：我要丢弃该commit（缩写:d）\n</code></pre></div><div class="language-"><pre><code>$ git rebase -i \npick caf7ca7 aa\npick b093fc3 bb\npick 946c0c3 cc   //这才是最后一条提交\n\n# Rebase acd67ed..a6ac5b0 onto acd67ed (11 commands)\n#\n# Commands:\n# p, pick &lt;commit&gt; = use commit\n# r, reword &lt;commit&gt; = use commit, but edit the commit message\n# e, edit &lt;commit&gt; = use commit, but stop for amending\n# s, squash &lt;commit&gt; = use commit, but meld into previous commit\n# f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#39;s log message\n# x, exec &lt;command&gt; = run command (the rest of the line) using shell\n</code></pre></div><p>输入 i 进入编辑修改操作指令，修改提交信息，比如将 aa 跟 bb drop 掉，然后将最后一条 cc 给 reword 修改注释，然后 esc 退出编辑， wq 保存，注意要至少保留一个 pick</p><div class="language-"><pre><code># //如果有冲突先解决冲突,如果 rebase 中途出现问题，可以使用git rebase --abort 恢复,停止操作。\n$ git rebase --continue  \n\n//如果你有使用 reword 或者 edit，这个时候会直接进入 vim 去编辑提交信息，编辑完后保存，跟前面的**git commit --amend**一样\n$ git push //提交，这个时候就只有一条commit信息\n</code></pre></div><p>使用 rebase 可以把一个分支的改动复制到另一个分支上，这个跟 cherry-pick 很类似</p><div class="language-"><pre><code># [startpoint] [endpoint]指定的是一个前开后闭的区间,所以起点要后退一步，或则使用 HEAD^,还记得前面的HEAD介绍吧\n# git rebase   [startpoint]   [endpoint]  --onto  [branchName]  \n$ git  rebase   90bc0045b^   5de0da9f2   --onto master\n\n# 切换到master\n$ git checkout master\n\n# //将master所指向的提交id设置为当前HEAD所指向的提交id\n$ git reset --hard  0c72e64  \n</code></pre></div><h2 id="merge"><a class="header-anchor" href="#merge" aria-hidden="true">#</a> merge</h2><blockquote><p>在 rebase 中已经讲过 merge 的用法了，在这里就讲一下 merge 的三个参数</p></blockquote><p><code>--ff</code>: (fast-forward)默认的提交方式。方式就是当条件允许（没有冲突的情况）的时候，git 直接把 HEAD 指针指向合并分支的头，完成合并。属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建 commit。</p><p><code>--no-ff</code>: 指的是强行关闭 fast-forward 方式。</p><p><code>--squash</code>: 是用来把一些不必要 commit 进行压缩，比如说，你的 feature 在开发的时候写的 commit 很乱，那么我们合并的时候不希望把这些历史 commit 带过来，于是使用 --squash 进行合并，此时文件已经同合并后一样了，但不移动 HEAD ，不提交。需要进行一次额外的 commit 来“总结”一下，然后完成最终的合并。</p><p>总结：默认不指定参数的情况下，没有冲突使用 --ff，不会多出来一个 merge commit，有冲突自动 --no-ff ，会自动生成一条 merge 信息</p><h2 id="cherry-pick"><a class="header-anchor" href="#cherry-pick" aria-hidden="true">#</a> cherry-pick</h2><blockquote><p>使用场景:当一个 bug 解决 或者功能 在 A 分支，这时 B 分支也需要这些 commit，那么可以使用 cherry-pick 将这些 commit 复制过来</p></blockquote><p>假设仓库中有三个分支：master、feature-a、feature-b。现在需要将 feature-a 中的两次 commit 合并到 feature-b 中</p><div class="language-"><pre><code># //切换到feature-a 分支\n$ git checkout feature-a\n\n# 查找需要的commit_id\n$ git reflog/git log \n\n# 使用cherry-pick 连续 6b95b5^...b09a488 \n3.git cherry-pick 6b95b5 b09a488 \n</code></pre></div><p>这时候，如果没有冲突的话， git log 就可以看到 feature-b 分支上会多出 2 次新的提交 这个时候它是自动提交的，如果想不自动提交，执行：git cherry-pick 6b95b5 b09a488 -n</p><p>发生冲突：</p><div class="language-"><pre><code># 自己手动解决完所有冲突,标记有冲突的文件已经解决好冲突\n$ git add -u \n\n# 除此以外，如果你过程中不想 cherry-pick了，只需执行：git cherry-pick --abort\n$ git cherry-pick --ontinue\n</code></pre></div><blockquote><p>注意：虽然表面上看似是将那两次提交拿过来再用一遍，但其实 Git 只是拿到修改生成了新的提交，因此，这里会看到这 2 个新的提交，commit-id 和我们挑选 commit-id 并不一致。</p></blockquote><p>其他有用参数：</p><ul><li>-e/--edit：进行 cherry-pick 时，会在进行新的提交之前，重新编辑提交的信息</li><li>x：在记录提交时，会在原始提交消息后添加一行 cherry picked from commit …，以表明此更改是从哪个提交中挑选出来的。 这仅适用于没有冲突的 cherry-pick</li><li>-s/--signoff：在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作</li></ul><h2 id="tag-标签"><a class="header-anchor" href="#tag-标签" aria-hidden="true">#</a> tag(标签)</h2><blockquote><p>Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）</p></blockquote><p><strong>轻量标签</strong>：就是简单输个标签名即可，不会有任何附带信息</p><div class="language-"><pre><code>$ git tag v1.0\n</code></pre></div><p><strong>附注标签</strong>：需要强制附带备注信息</p><div class="language-"><pre><code>$ git tag -a v1.0 -m 第一次发版\n</code></pre></div><p>查看标签信息与对应的提交信息：</p><div class="language-"><pre><code>$ git show /git show v1.0\n</code></pre></div><p>给指定的提交历史打标签</p><div class="language-"><pre><code>$ git tag -a v1.0 9fceb02\n</code></pre></div><p>推送标签到远程：不需要指定分支，它会在远程仓库共享，在仓库中可以找到 tag 并查看,不推送到远程只能在本地查看</p><div class="language-"><pre><code>$ git push origin v1.0 \n\nEnumerating objects: 29, done.\nCounting objects: 100% (29/29), done.\nDelta compression using up to 4 threads\nCompressing objects: 100% (20/20), done.\nWriting objects: 100% (27/27), 2.29 KiB | 782.00 KiB/s, done.\nTotal 27 (delta 6), reused 0 (delta 0), pack-reused 0\nTo https://git.vankeservice.com/v0840985/jiang.git\n * [new tag]         v1.0 -&gt; v1.0\n</code></pre></div><p>删除标签</p><div class="language-"><pre><code># 删除本地标签\n$ git tag -d v1.0\n\n# 删除远程标签\n$ git push origin -d v1.0\n</code></pre></div><h2 id="gitignore"><a class="header-anchor" href="#gitignore" aria-hidden="true">#</a> .gitignore</h2><blockquote><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。</p></blockquote><div class="language-"><pre><code># 此为注释 – 将被 Git 忽略\n# 忽略所有 .a 结尾的文件\n*.a\n# 但 lib.a 除外\n!lib.a\n# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\n/TODO\n# 忽略 build/ 目录下的所有文件\nbuild/\n# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\ndoc/*.txt\n# 忽略 doc/ 目录下所有扩展名为 txt 的文件\ndoc/**/*.txt\n</code></pre></div><h2 id="gitkeep"><a class="header-anchor" href="#gitkeep" aria-hidden="true">#</a> .gitkeep</h2><blockquote><p>.gitkeep是一个占位文件。 Git是不会把一个完全空的文件夹添加到版本控制里，为了让空文件夹被跟踪，常规做法是在空文件夹里添加.gitkeep。</p></blockquote>',185);r.render=function(i,a,r,o,c,s){return t(),e("div",null,[n])};export default r;export{a as __pageData};
