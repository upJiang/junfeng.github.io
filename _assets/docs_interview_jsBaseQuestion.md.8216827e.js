import{g as e,f as a,E as r}from"./common-d6bd45c0.js";const t='{"title":"js如何获取元素顶部距离浏览器的距离","frontmatter":{},"headers":[{"level":2,"title":"js如何获取元素顶部距离浏览器的距离","slug":"js如何获取元素顶部距离浏览器的距离"},{"level":2,"title":"axios跟ajax的区别","slug":"axios跟ajax的区别"},{"level":2,"title":"遍历对象的方式，可以遍历原型吗？","slug":"遍历对象的方式，可以遍历原型吗？"},{"level":2,"title":"如何判断一个属性是属于对象本身还是属于他的原型？","slug":"如何判断一个属性是属于对象本身还是属于他的原型？"},{"level":2,"title":"nodejs了解什么","slug":"nodejs了解什么"},{"level":2,"title":"计时器倒计时三天，如何计算误差最小","slug":"计时器倒计时三天，如何计算误差最小"},{"level":2,"title":"=== 与 == 的区别","slug":"与-的区别"},{"level":2,"title":"css中毛玻璃如何实现","slug":"css中毛玻璃如何实现"},{"level":2,"title":"rem跟em的区别","slug":"rem跟em的区别"},{"level":2,"title":"AJAX的原理","slug":"ajax的原理"},{"level":2,"title":"git与svn的区别","slug":"git与svn的区别"},{"level":2,"title":"什么是事件委托？","slug":"什么是事件委托？"},{"level":2,"title":"dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点","slug":"dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点"},{"level":2,"title":"equestIdleCallback是干什么用的","slug":"equestidlecallback是干什么用的"},{"level":2,"title":"浏览器渲染页面的原理及流程","slug":"浏览器渲染页面的原理及流程"},{"level":2,"title":"关键渲染路径详述","slug":"关键渲染路径详述"},{"level":2,"title":"为什么说script标签建议放在body下面？","slug":"为什么说script标签建议放在body下面？"},{"level":2,"title":"为什么说script标签会阻塞页面的渲染呢？渲染线程和js引擎线程不是分开的吗？","slug":"为什么说script标签会阻塞页面的渲染呢？渲染线程和js引擎线程不是分开的吗？"},{"level":2,"title":"null == undefined","slug":"null-undefined"},{"level":2,"title":"当静态资源 cdn 挂掉怎么办？怎么切换另一个？","slug":"当静态资源-cdn-挂掉怎么办？怎么切换另一个？"},{"level":2,"title":"如何中断请求？","slug":"如何中断请求？"},{"level":2,"title":"为什么使用 css3 动画比 js 动画 更快？","slug":"为什么使用-css3-动画比-js-动画-更快？"}],"relativePath":"docs/interview/jsBaseQuestion.md","lastUpdated":1646666303087.2832}';var l={};const s=r('<p><a href="https://juejin.cn/post/6992767550543265829" target="_blank" rel="noopener noreferrer">前端万字面经</a></p><p><a href="https://mp.weixin.qq.com/s/STRtbYjyPO7dQWRDtiQOlQ" target="_blank" rel="noopener noreferrer">37个JavaScript基本面试问题和解答</a></p><h2 id="js如何获取元素顶部距离浏览器的距离"><a class="header-anchor" href="#js如何获取元素顶部距离浏览器的距离" aria-hidden="true">#</a> js如何获取元素顶部距离浏览器的距离</h2><p>document.documentElement.scrollTop</p><h2 id="axios跟ajax的区别"><a class="header-anchor" href="#axios跟ajax的区别" aria-hidden="true">#</a> axios跟ajax的区别</h2><p>axios就是promise封装的ajax，相当于jq跟js</p><h2 id="遍历对象的方式，可以遍历原型吗？"><a class="header-anchor" href="#遍历对象的方式，可以遍历原型吗？" aria-hidden="true">#</a> 遍历对象的方式，可以遍历原型吗？</h2><p>for in 以任意顺序遍历一个对象的除Symbol以外的可枚举属性</p><p>Object.keys() 返回一个由一个给定对象的自身可枚举属性组成的数组</p><h2 id="如何判断一个属性是属于对象本身还是属于他的原型？"><a class="header-anchor" href="#如何判断一个属性是属于对象本身还是属于他的原型？" aria-hidden="true">#</a> 如何判断一个属性是属于对象本身还是属于他的原型？</h2><p>用hasownproperty</p><h2 id="nodejs了解什么"><a class="header-anchor" href="#nodejs了解什么" aria-hidden="true">#</a> nodejs了解什么</h2><p>比如express用来搭建本地服务器 require exports导入导出 文件系统模块fs，path 获取文件绝对路径 __dirname __filename 全局对象global</p><h2 id="计时器倒计时三天，如何计算误差最小"><a class="header-anchor" href="#计时器倒计时三天，如何计算误差最小" aria-hidden="true">#</a> 计时器倒计时三天，如何计算误差最小</h2><ol><li>使用 requestAnimationFrame（按照屏幕刷新率去定时调用，一般默认60ms)，在这个方法中重新获取当前时间去抵消误差，减去差值），但对于要求60ms延迟以下的要考虑别的方法。</li><li>使用 web Worker将定时函数作为独立线程执行</li></ol><div class="language-"><pre><code>// worker 解决方案 \nlet worker = new Worker(&#39;./preciseTiming.js&#39;)\n// preciseTiming.js\nvar startTime = new Date().getTime();\nvar count = 0;\nsetInterval(function(){\n    count++;\n    console.log(`${count}---${(new Date().getTime() - (startTime + count * 1000)}`);\n}, 1000);\n</code></pre></div><h2 id="与-的区别"><a class="header-anchor" href="#与-的区别" aria-hidden="true">#</a> === 与 == 的区别</h2><p>===包括类型相等</p><h2 id="css中毛玻璃如何实现"><a class="header-anchor" href="#css中毛玻璃如何实现" aria-hidden="true">#</a> css中毛玻璃如何实现</h2><p>只是用到了 css 滤镜（filter）中的 blur 属性</p><p><a href="https://www.cnblogs.com/ivan5277/p/10007273.html" target="_blank" rel="noopener noreferrer">css中毛玻璃如何实现</a></p><h2 id="rem跟em的区别"><a class="header-anchor" href="#rem跟em的区别" aria-hidden="true">#</a> rem跟em的区别</h2><p>移动端1rem默认16px,字体大小16px</p><p>rem 单位翻译为像素值是由 html 元素的字体大小决定的。 此字体大小会被浏览器中字体大小的设置影响，除非显式重写一个具体单位。</p><p>em 单位转为像素值，取决于他们使用的字体大小。 此字体大小受从父元素继承过来的字体大小，除非显式重写与一个具体单位。</p><h2 id="ajax的原理"><a class="header-anchor" href="#ajax的原理" aria-hidden="true">#</a> AJAX的原理</h2><p>Ajax的工作原理相当于在用户和服 务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给 Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p><p>Ajax其核心有 JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据， 然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。</p><h2 id="git与svn的区别"><a class="header-anchor" href="#git与svn的区别" aria-hidden="true">#</a> git与svn的区别</h2><p>a、存储方式不一样<br> Git按照元数据的方式将文件的一个版本存入了一个类似与K/V数据库，而SVN是按照文件的方式进行一个存储</p><p>b、使用方式不一样<br> 从本地把文件推送到远程服务，SVN只需要commit而Git需要add、commit、push三个步骤 使用SVN开发者只要把文件修改了，只要commit其他开发人员就可以直接checkout下来 但是Git就不相同了，Git如果要从本地将修改后的文件提交进入远程仓库再从远程仓库将其他开发者修改后的文件</p><h2 id="什么是事件委托？"><a class="header-anchor" href="#什么是事件委托？" aria-hidden="true">#</a> 什么是事件委托？</h2><p>事件代理又称事件委托，是javaScript中绑定事件的常用技巧。顾名思义，‘事件代理’就是把原本需要绑定的事件委托给父元素，让父元素负责事件监听。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</p><p>比方说对于li的一些监听操作，不在li上写，在ul上写，这样就减少了监听的次数</p><h2 id="dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点"><a class="header-anchor" href="#dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点" aria-hidden="true">#</a> dom树节点和渲染树节点一一对应吗，有什么是dom树会有，渲染树不会有的节点</h2><p>不是一一对应，比如head节点，dom树+cssRules = 渲染树，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。</p><p>构建渲染树，根据渲染树计算每个可见元素的布局，并输出到绘制流程，将像素渲染到屏幕上。</p><p>对于一个HTML文档来说，不管是内联还是外链的css，都会阻碍后续的dom渲染，但是不会阻碍后续dom的解析</p><p><a href="https://blog.csdn.net/Gbing1228/article/details/103575756" target="_blank" rel="noopener noreferrer">参考</a></p><h2 id="equestidlecallback是干什么用的"><a class="header-anchor" href="#equestidlecallback是干什么用的" aria-hidden="true">#</a> equestIdleCallback是干什么用的</h2><p>requestIdleCallback会在帧结束时并且有空闲时间。或者用户不与网页交互时，执行回调</p><p><a href="https://www.lagou.com/lgeduarticle/105035.html" target="_blank" rel="noopener noreferrer">参考</a></p><h2 id="浏览器渲染页面的原理及流程"><a class="header-anchor" href="#浏览器渲染页面的原理及流程" aria-hidden="true">#</a> 浏览器渲染页面的原理及流程</h2><blockquote><p>js会阻塞dom树的构建，因为js可能会改变dom树的结构，无法预知，所以只能停止dom树的构建，等待js完成。所以js一般要在最后写</p></blockquote><p><a data-fancybox title="image.png" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d03fc74582348268cceca5334ea4b6d~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d03fc74582348268cceca5334ea4b6d~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p><a href="https://www.cnblogs.com/chenyoumei/p/9156849.html" target="_blank" rel="noopener noreferrer">参考</a></p><h2 id="关键渲染路径详述"><a class="header-anchor" href="#关键渲染路径详述" aria-hidden="true">#</a> 关键渲染路径详述</h2><p>就是优化首页加载</p><p><a href="https://www.cnblogs.com/zechau/p/5979683.html" target="_blank" rel="noopener noreferrer">参考</a></p><h2 id="为什么说script标签建议放在body下面？"><a class="header-anchor" href="#为什么说script标签建议放在body下面？" aria-hidden="true">#</a> 为什么说script标签建议放在body下面？</h2><p>JS代码在加载完之后是立即执行的，且JS代码执行时会阻塞页面的渲染。</p><h2 id="为什么说script标签会阻塞页面的渲染呢？渲染线程和js引擎线程不是分开的吗？"><a class="header-anchor" href="#为什么说script标签会阻塞页面的渲染呢？渲染线程和js引擎线程不是分开的吗？" aria-hidden="true">#</a> 为什么说script标签会阻塞页面的渲染呢？渲染线程和js引擎线程不是分开的吗？</h2><p>JS属于单线程，当我们在加载script标签内容的时候，渲染线程会被暂停，因为script标签里可能会操作DOM的，所以如果你加载script标签又同时渲染页面肯定就冲突了，因此说渲染线程(GUI)和js引擎线程互斥。</p><h2 id="null-undefined"><a class="header-anchor" href="#null-undefined" aria-hidden="true">#</a> null == undefined</h2><div class="language-"><pre><code>console.log( undefined == null )  //true\n</code></pre></div><p>undefined 和 null 都是 false ,所有他们是 true ? 错误 <a data-fancybox title="img" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e8c2c58d6009b~tplv-t2oaga2asx-watermark.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e8c2c58d6009b~tplv-t2oaga2asx-watermark.awebp" alt="img"></a></p><p><a data-fancybox title="img" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e8c4c6155aef8~tplv-t2oaga2asx-watermark.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/17/170e8c4c6155aef8~tplv-t2oaga2asx-watermark.awebp" alt="img"></a></p><h2 id="当静态资源-cdn-挂掉怎么办？怎么切换另一个？"><a class="header-anchor" href="#当静态资源-cdn-挂掉怎么办？怎么切换另一个？" aria-hidden="true">#</a> 当静态资源 cdn 挂掉怎么办？怎么切换另一个？</h2><div class="language-"><pre><code>&lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;window.jQuery || document.write(&#39;&lt;script src=&quot;js/vendor/jquery-1.10.2.min.js&quot;&gt;&lt;\\/script&gt;&#39;)&lt;/script&gt;\n</code></pre></div><p>思路其实就是判断引入的资源是否存在，不存在使用 document.write 写入另一个 cdn或者本地资源</p><h2 id="如何中断请求？"><a class="header-anchor" href="#如何中断请求？" aria-hidden="true">#</a> 如何中断请求？</h2><p>使用axios 的cancelToken,用法</p><div class="language-"><pre><code>const CancelToken = axios.CancelToken;\nconst source = CancelToken.source();\naxios.get(&#39;/user/12345&#39;, {//get请求在第二个参数\n    cancelToken: source.token\n}).catch(function(thrown) {\n});\naxios.post(&#39;/user/12345&#39;, {//post请求在第三个参数\n    name: &#39;new name&#39;\n}, {\n    cancelToken: source.token\n});\nsource.cancel(&#39;不想请求了&#39;);\n用法二\n</code></pre></div><h2 id="为什么使用-css3-动画比-js-动画-更快？"><a class="header-anchor" href="#为什么使用-css3-动画比-js-动画-更快？" aria-hidden="true">#</a> 为什么使用 css3 动画比 js 动画 更快？</h2><p>CSS3 动画也被称为<code>补间动画</code>，原因是只需要添加关键帧的位置，其他的未定义的帧会被自动生成。我们只需要设置几个关键帧的位置。<br> 优势：</p><ul><li>浏览器可以对动画进行优化</li><li>帧速不好的浏览器，CSS3 可以自然降级兼容</li><li>代码简单，调优方向固定</li></ul><p>JS 动画是逐帧动画，在时间帧上绘制内容，一帧一帧的，所以他的可再造性很高，几乎可以完成任何你想要的动画形式。但是由于逐帧动画的内容不一样，会增加制作的负担，占用比较大的资源空间。<br> 优势：</p><ul><li>细腻的动画</li><li>可控性高</li><li>炫酷高级的动画</li></ul><p>对比：<br> 使用 js 必然会涉及到几何属性的改变那么必然导致<code>回流</code>，会造成浏览器在不断的计算页面，主线程中还有其他的重要任务在运行，因而可能会受到干扰导致线程阻塞，从而丢帧。</p><p>而 CSS 的动画是运行在合成线程中的，不会阻塞主线程，并且在合成线程中完成的动作不会触发回流和重绘。JS 动画运行在 CPU，而 CSS 动画运行在 GPU。总的来说， CSS动画的渲染成本小，并且它的执行效率高于 JavaScript 动画</p><p><strong>CSS动画比JS动画流畅的前提</strong></p><ul><li>CSS动画比较少或者不触发pain和layout，即重绘和重排时。例如通过改变如下属性生成的css动画，这时整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）： <ul><li>backface-visibility：该属性指定当元素背面朝向观察者时是否可见（3D，实验中的功能）；</li><li>opacity：设置 div 元素的不透明级别；</li><li>perspective 设置元素视图，该属性只影响 3D 转换元素；</li><li>perspective-origin：该属性允许您改变 3D 元素的底部位置；</li><li>transform：该属性应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。</li></ul></li><li>JS在执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅；</li><li>部分属性能够启动3D加速和GPU硬件加速，例如使用transform的translateZ进行3D变换时；</li><li>通过设置 will-change 属性，浏览器就可以提前知道哪些元素的属性将会改变，提前做好准备。待需要改变元素的时机到来时，就可以立刻实现它们，从而避免卡顿等问题。 <ul><li>不要将 will-change 应用到太多元素上，如果过度使用的话，可能导致页面响应缓慢或者消耗非常多的资源。</li><li>例如下面的代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。 <ul><li><div class="language-"><pre><code>   .box {will-change: transform, opacity;}\n</code></pre></div></li></ul></li></ul></li></ul>',72);l.render=function(r,t,l,i,n,c){return a(),e("div",null,[s])};export default l;export{t as __pageData};
