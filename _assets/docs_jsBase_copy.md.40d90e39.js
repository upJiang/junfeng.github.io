import{g as e,f as a,E as n}from"./common-d6bd45c0.js";const o='{"title":"浅拷贝的实现方式","frontmatter":{},"headers":[{"level":2,"title":"浅拷贝的实现方式","slug":"浅拷贝的实现方式"},{"level":2,"title":"深拷贝的实现方式","slug":"深拷贝的实现方式"}],"relativePath":"docs/jsBase/copy.md","lastUpdated":1639657876228.9238}';var r={};const t=n('<p>浅拷贝：浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中<strong>一个对象改变了这个地址，就会影响到另一个对象</strong>。</p><p><a data-fancybox title="image.png" href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a286afa3c40484099245852f4258a4a~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0a286afa3c40484099245852f4258a4a~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p>深拷贝：深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</p><p><a data-fancybox title="image.png" href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0408fb610734ceb8dbbbf7441a85992~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0408fb610734ceb8dbbbf7441a85992~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><div class="language-"><pre><code>var a1 = {b: {c: {}};\n\nvar a2 = shallowClone(a1); // 浅拷贝方法\na2.b.c === a1.b.c // true 新旧对象还是共享同一块内存\n\nvar a3 = deepClone(a3); // 深拷贝方法\na3.b.c === a1.b.c // false 新对象跟原对象不共享内存\n\n</code></pre></div><blockquote><p>总而言之，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p></blockquote><h2 id="浅拷贝的实现方式"><a class="header-anchor" href="#浅拷贝的实现方式" aria-hidden="true">#</a> 浅拷贝的实现方式</h2><p>1.Object.assign()</p><blockquote><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p></blockquote><div class="language-"><pre><code>let obj1 = { person: {name: &quot;kobe&quot;, age: 41},sports:&#39;basketball&#39; };\nlet obj2 = Object.assign({}, obj1);\nobj2.person.name = &quot;wade&quot;;\nobj2.sports = &#39;football&#39;\nconsole.log(obj1); // { person: { name: &#39;wade&#39;, age: 41 }, sports: &#39;basketball&#39; }\n</code></pre></div><p>2.函数库lodash的_.clone方法</p><blockquote><p>该函数库也有提供_.clone用来做 Shallow Copy,后面我们会再介绍利用这个库实现深拷贝。</p></blockquote><div class="language-"><pre><code>var _ = require(&#39;lodash&#39;);\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = _.clone(obj1);\nconsole.log(obj1.b.f === obj2.b.f);// true\n</code></pre></div><p>3.展开运算符...</p><blockquote><p>展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。</p></blockquote><div class="language-"><pre><code>let obj1 = { name: &#39;Kobe&#39;, address:{x:100,y:100}}\nlet obj2= {... obj1}\nobj1.address.x = 200;\nobj1.name = &#39;wade&#39;\nconsole.log(&#39;obj2&#39;,obj2) // obj2 { name: &#39;Kobe&#39;, address: { x: 200, y: 100 } }\n</code></pre></div><p>4.Array.prototype.concat()</p><div class="language-"><pre><code>let arr = [1, 3, {\n    username: &#39;kobe&#39;\n    }];\nlet arr2 = arr.concat();    \narr2[2].username = &#39;wade&#39;;\nconsole.log(arr); //[ 1, 3, { username: &#39;wade&#39; } ]\n</code></pre></div><p>5.Array.prototype.slice()</p><div class="language-"><pre><code>let arr = [1, 3, {\n    username: &#39; kobe&#39;\n    }];\nlet arr3 = arr.slice();\narr3[2].username = &#39;wade&#39;\nconsole.log(arr); // [ 1, 3, { username: &#39;wade&#39; } ]\n</code></pre></div><h2 id="深拷贝的实现方式"><a class="header-anchor" href="#深拷贝的实现方式" aria-hidden="true">#</a> 深拷贝的实现方式</h2><p>1.JSON.parse(JSON.stringify())</p><div class="language-"><pre><code>let arr = [1, 3, {\n    username: &#39; kobe&#39;\n}];\nlet arr4 = JSON.parse(JSON.stringify(arr));\narr4[2].username = &#39;duncan&#39;; \nconsole.log(arr, arr4)\n</code></pre></div><p><a data-fancybox title="image.png" href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbfb74327856429f9844da11f691d103~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbfb74327856429f9844da11f691d103~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p>这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p><p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则</strong>，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。</p><p>比如下面的例子：</p><div class="language-"><pre><code>let arr = [1, 3, {\n    username: &#39; kobe&#39;\n},function(){}];\nlet arr4 = JSON.parse(JSON.stringify(arr));\narr4[2].username = &#39;duncan&#39;; \nconsole.log(arr, arr4)\n</code></pre></div><p><a data-fancybox title="image.png" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f99f16a4cb4eada1159cf3e7a9a299~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f99f16a4cb4eada1159cf3e7a9a299~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p>2.函数库lodash的_.cloneDeep方法</p><blockquote><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p></blockquote><div class="language-"><pre><code>var _ = require(&#39;lodash&#39;);\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = _.cloneDeep(obj1);\nconsole.log(obj1.b.f === obj2.b.f);// false\n</code></pre></div><p>3.jQuery.extend()方法</p><blockquote><p>jquery 有提供一個$.extend可以用来做 Deep Copy</p></blockquote><div class="language-"><pre><code>$.extend(deepCopy, target, object1, [objectN])//第一个参数为true,就是深拷贝\n\nvar $ = require(&#39;jquery&#39;);\nvar obj1 = {\n    a: 1,\n    b: { f: { g: 1 } },\n    c: [1, 2, 3]\n};\nvar obj2 = $.extend(true, {}, obj1);\nconsole.log(obj1.b.f === obj2.b.f); // false\n</code></pre></div><p>4.手写递归方法</p><p>递归方法实现深度克隆原理：<strong>遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong>。</p><p>有种特殊情况需注意就是对象存在循环引用的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。关于这块如有疑惑，请仔细阅读<a href="https://segmentfault.com/a/1190000020255831" target="_blank" rel="noopener noreferrer">ConardLi大佬如何写出一个惊艳面试官的深拷贝?这篇文章</a>。</p><div class="language-"><pre><code>function deepClone(obj, hash = new WeakMap()) {\n  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作\n  if (obj instanceof Date) return new Date(obj);\n  if (obj instanceof RegExp) return new RegExp(obj);\n  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝\n  if (typeof obj !== &quot;object&quot;) return obj;\n  // 是对象的话就要进行深拷贝\n  if (hash.get(obj)) return hash.get(obj);\n  let cloneObj = new obj.constructor();\n  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身\n  hash.set(obj, cloneObj);\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      // 实现一个递归拷贝\n      cloneObj[key] = deepClone(obj[key], hash);\n    }\n  }\n  return cloneObj;\n}\nlet obj = { name: 1, address: { x: 100 } };\nobj.o = obj; // 对象存在循环引用的情况\nlet d = deepClone(obj);\nobj.address.x = 200;\nconsole.log(d);\n</code></pre></div><p><a href="https://juejin.cn/post/6844904197595332622" target="_blank" rel="noopener noreferrer">参考文章</a></p>',40);r.render=function(n,o,r,p,c,s){return a(),e("div",null,[t])};export default r;export{o as __pageData};
