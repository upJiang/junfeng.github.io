import{g as e,f as o,E as n}from"./common-d6bd45c0.js";const r='{"title":"CommonJS","frontmatter":{},"headers":[{"level":2,"title":"CommonJS","slug":"commonjs"},{"level":2,"title":"AMD","slug":"amd"},{"level":2,"title":"CMD/AMD","slug":"cmd-amd"},{"level":2,"title":"CommonJS和ES6模块的区别","slug":"commonjs和es6模块的区别"},{"level":3,"title":"require","slug":"require"},{"level":3,"title":"import","slug":"import"}],"relativePath":"docs/jsBase/module.md","lastUpdated":1639657876253.9124}';var t={};const i=n('<blockquote><p>前端模块化就是复杂的文件编程一个一个独立的模块，比如js文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了commonJS 规范，AMD，CMD规范等等，以及用于js打包（编译等处理）的工具 webpack</p></blockquote><h2 id="commonjs"><a class="header-anchor" href="#commonjs" aria-hidden="true">#</a> CommonJS</h2><blockquote><p>NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写</p></blockquote><p>浏览器不能兼容，因为require是同步的，需要等待的，如果我们去使用同步获取服务器信息，那么浏览器将会“假死”状态，并且浏览器也没有module、exports、require、global这四个node变量</p><p>CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}，运行时加载</p><p>转换工具： Browserify</p><div class="language-"><pre><code>//foo.js\nmodule.exports = function(x) {\n  console.log(x);\n};\n//main.js\nvar foo = require(&quot;./foo&quot;);\nfoo(&quot;Hi&quot;);\n========================》》》》》》\n[\n  {\n    &quot;id&quot;:1,\n    &quot;source&quot;:&quot;module.exports = function(x) {\\n  console.log(x);\\n};&quot;,\n    &quot;deps&quot;:{}\n  },\n  {\n    &quot;id&quot;:2,\n    &quot;source&quot;:&quot;var foo = require(\\&quot;./foo\\&quot;);\\nfoo(\\&quot;Hi\\&quot;);&quot;,\n    &quot;deps&quot;:{&quot;./foo&quot;:1},\n    &quot;entry&quot;:true\n  }\n]\nbrowerify 将所有模块放入一个数组，id 属性是模块的编号，source 属性是模块的源码，deps 属性是模块的依赖。\n</code></pre></div><h2 id="amd"><a class="header-anchor" href="#amd" aria-hidden="true">#</a> AMD</h2><p>异步模块定义，就是为了解决commonjs同步等待的问题，使用异步加载，不影响后面代码的执行， AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p><div class="language-"><pre><code>// math.js\n　　define(function (){\n　　　　var add = function (x,y){\n　　　　　　return x+y;\n　　　　};\n        var ccc = function (x,y){\n　　　　　　return x+y;\n　　　　};\n　　　　return {\n　　　　　　add: add,\n                    ccc:ccc\n　　　　};\n});\nrequire([&#39;math&#39;], function (math) {\n　　math.add(2, 3);\n});\n\n注意：如果定义的模块依赖于别的模块，那么第一个参数是一个依赖模块的数组，使用require.js的插件可以不一样写\ndefine([&#39;dep1&#39;,&#39;dep2&#39;],function(dep1,dep2){...});\n</code></pre></div><p><strong>RequireJS</strong>就是实现了AMD规范，比如说在项目中使用require.js，然后设置主入口去异步加载别的模块</p><div class="language-"><pre><code>&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;\n假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：\nrequire([&#39;jquery&#39;, &#39;underscore&#39;, &#39;backbone&#39;], function ($, _, Backbone){\n　　　　// some code here\n});\n或者\nrequire.config({\n　　　　baseUrl: &quot;js/lib&quot;,\n　　　　paths: {\n　　　　　　&quot;jquery&quot;: &quot;jquery.min&quot;,\n　　　　　　&quot;underscore&quot;: &quot;underscore.min&quot;,\n　　　　　　&quot;backbone&quot;: &quot;backbone.min&quot;\n　　　　}\n});\n</code></pre></div><h2 id="cmd-amd"><a class="header-anchor" href="#cmd-amd" aria-hidden="true">#</a> CMD/AMD</h2><blockquote><p>通用模块定义 seajs CMD 推崇依赖就近，AMD 推崇依赖前置 ,AMD主张以来一开始加载完毕，而CMD主张需要用到时才加载</p></blockquote><div class="language-"><pre><code>define(function(require, exports, module) {\nvar a = require(&#39;./a&#39;)\na.doSomething()\n// 此处略去 100 行\nvar b = require(&#39;./b&#39;) // 依赖可以就近书写\nb.doSomething()\n// ...\n})\n</code></pre></div><p>AMD | 速度快 | 会浪费资源 | 预先加载所有的依赖，直到使用的时候才执行</p><p>CMD | 只有真正需要才加载依赖 | 性能较差 | 直到使用的时候才定义依赖</p><h2 id="commonjs和es6模块的区别"><a class="header-anchor" href="#commonjs和es6模块的区别" aria-hidden="true">#</a> CommonJS和ES6模块的区别</h2><ul><li>CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</li><li>CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li><li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是require()方法；而ES6 Modules只能是字符串</li><li>CommonJS this指向当前模块，ES6 Modules this指向undefined</li><li>且ES6 Modules中没有这些顶层变量：arguments、require、module、exports、__filename、__dirname</li></ul><h3 id="require"><a class="header-anchor" href="#require" aria-hidden="true">#</a> require</h3><ol><li>CommonJs的语法（AMD规范引入方式），CommonJs的模块是对象。</li><li>运行时加载整个模块（即模块中所有方法），生成一个对象，再从对象上读取它的方法（只有运行时才能得到这 个对象,不能在编译时做到静态化），理论上可以用在代码的任何地方</li><li>require是赋值过程，把require的结果（对象，数字，函数等），默认是export的一个对象，赋给某个变量（复制或浅拷贝）</li></ol><h3 id="import"><a class="header-anchor" href="#import" aria-hidden="true">#</a> import</h3><ol><li>es6的一个语法标准（浏览器不支持，本质是使用node中的babel将es6转码为es5再执行，import会被转码为require），es6模块不是对象</li><li>是编译时调用，确定模块的依赖关系，输入变量（es6模块不是对象，而是通过export命令指定输出代码，再通过import输入，只加载import中导的方法，其他方法不加载），import具有提升效果，会提升到模块的头部（编译时执行）</li><li>import是解构过程（需要谁，加载谁） <a data-fancybox title="image.png" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f9766ff131848279424d1af6ad0d269~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f9766ff131848279424d1af6ad0d269~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></li></ol>',23);t.render=function(n,r,t,u,a,d){return o(),e("div",null,[i])};export default t;export{r as __pageData};
