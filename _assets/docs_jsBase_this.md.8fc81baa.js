import{g as n,f as t,E as a}from"./common-d6bd45c0.js";const i='{"title":"this指向的方式","frontmatter":{},"headers":[{"level":2,"title":"this指向的方式","slug":"this指向的方式"},{"level":2,"title":"改变this指向","slug":"改变this指向"},{"level":2,"title":"bind、apply、call","slug":"bind、apply、call"},{"level":3,"title":"相似之处","slug":"相似之处"},{"level":3,"title":"区别","slug":"区别"},{"level":2,"title":"手写call,apply,bind","slug":"手写call-apply-bind"}],"relativePath":"docs/jsBase/this.md","lastUpdated":1627826666657.2964}';var l={};const e=a('<h2 id="this指向的方式"><a class="header-anchor" href="#this指向的方式" aria-hidden="true">#</a> this指向的方式</h2><div class="language-"><pre><code>① 在普通函数中，this指向window\n② 在构造函数中，this指向创建的对象\n③ 在方法声明中，this指向调用者\n④ 在定时器中， this指向window\n⑤ 在事件中，this 指向事件源\n\n//this指向window\nfunction foo() {\nconsole.log(this.a)\n}\nvar a = 1foo()   \n\n//this指向obj，调用foo的对象上\nconst obj = {\na: 2,\nfoo: foo\n}\nobj.foo()\n\n//this指向new这个函数上，即c\nconst c = new foo()\n\n//箭头函数的this指向定义这个函数的位置，bind，apply无效，此时this指向window\nfunction a() {\n    return () =&gt; {\n        return () =&gt; {\n            console.log(this)\n        }\n    }}\n}\n</code></pre></div><h2 id="改变this指向"><a class="header-anchor" href="#改变this指向" aria-hidden="true">#</a> 改变this指向</h2><p>1.使用bind</p><div class="language-"><pre><code>var foo = {\nx: 3\n}\nvar bar = function(){\nconsole.log(this.x);\n}\nbar(); // undefined\n\nvar boundFunc = bar.bind(foo); //使用bind将this绑定到window上，可以访问到foo\nboundFunc(); // 3\n</code></pre></div><p>2.let self = this<br> 3.立即执行函数(function(j) {})(i)</p><h2 id="bind、apply、call"><a class="header-anchor" href="#bind、apply、call" aria-hidden="true">#</a> bind、apply、call</h2><p>在说区别之前还是先总结一下三者的相似之处：<br></p><h3 id="相似之处"><a class="header-anchor" href="#相似之处" aria-hidden="true">#</a> 相似之处</h3><p>1、都是用来改变函数的this对象的指向的。<br> 2、第一个参数都是this要指向的对象。<br> 3、都可以利用后续参数传参。</p><h3 id="区别"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h3><p>1.call、apply与bind都用于改变this绑定，但call、apply在改变this指向的同时还会执行函数，而bind在改变this后是返回一个全新的boundFcuntion绑定函数，这也是为什么上方例子中bind后还加了一对括号 ()的原因。</p><p>2.bind属于硬绑定，返回的 boundFunction 的 this 指向无法再次通过bind、apply或 call 修改；call与apply的绑定只适用当前调用，调用完就没了，下次要用还得再次绑。</p><p>3.call与apply功能完全相同，唯一不同的是call方法传递函数调用形参是以散列形式，而apply方法的形参是一个数组。在传参的情况下，call的性能要高于apply，因为apply在执行时还要多一步解析数组。</p><p>wx.say.bind(this) 不能立即执行，无效，必须wx.say.bind(this)(&quot;aaa&quot;),参数置后<br> wx.say.call(this,&quot;aaa&quot;,&quot;bbb&quot;) 立即执行<br> wx.say.apply(this,[&quot;aaa&quot;,&quot;bbb&quot;]) 立即执行,参数为数组</p><h2 id="手写call-apply-bind"><a class="header-anchor" href="#手写call-apply-bind" aria-hidden="true">#</a> 手写call,apply,bind</h2><div class="language-"><pre><code>Function.prototype.myCall = \n    function (ctx) { \n    ctx = ctx || window; \n    ctx.fn = this; \n    let args = Array.from(arguments).slice(1); \n    let res = ctx.fn(...args); \n    delete ctx.fn; \n    return res;\n}; \nFunction.prototype.myApply = function (ctx) { \n    ctx = ctx || window; \n    ctx.fn = this; \n    let args = Array.from(arguments[1]); \n    let res = ctx.fn(...args); \n    delete ctx.fn; \n    return res; \n};\nFunction.prototype.myBind = function (ctx) { \n    let args = Array.from(arguments).slice(1); \n    let that = this; \n    return function (...oargs) \n        { \n            return that.apply(ctx, [...args, ...oargs]); \n        };\n };\n</code></pre></div>',17);l.render=function(a,i,l,o,s,r){return t(),n("div",null,[e])};export default l;export{i as __pageData};
