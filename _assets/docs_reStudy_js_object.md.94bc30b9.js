import{g as e,f as r,E as a}from"./common-d6bd45c0.js";const t='{"title":"基于对象的定义","frontmatter":{},"headers":[{"level":2,"title":"基于对象的定义","slug":"基于对象的定义"},{"level":2,"title":"对象的特征","slug":"对象的特征"},{"level":2,"title":"对象的两类属性","slug":"对象的两类属性"},{"level":2,"title":"数据属性","slug":"数据属性"},{"level":2,"title":"访问器（getter/setter）属性","slug":"访问器（getter-setter）属性"},{"level":2,"title":"对象分类","slug":"对象分类"},{"level":3,"title":"宿主对象","slug":"宿主对象"},{"level":3,"title":"内置对象·固有对象","slug":"内置对象·固有对象"},{"level":3,"title":"内置对象·原生对象","slug":"内置对象·原生对象"},{"level":2,"title":"函数对象与构造器对象","slug":"函数对象与构造器对象"},{"level":3,"title":"特殊行为的对象","slug":"特殊行为的对象"}],"relativePath":"docs/reStudy/js_object.md","lastUpdated":1639657876309.8772}';var n={};const l=a('<h2 id="基于对象的定义"><a class="header-anchor" href="#基于对象的定义" aria-hidden="true">#</a> 基于对象的定义</h2><p>语言和宿主的基础设施由对象来提供，并且 JavaScript 程序即是一系列互相通讯的对象集合</p><h2 id="对象的特征"><a class="header-anchor" href="#对象的特征" aria-hidden="true">#</a> 对象的特征</h2><ol><li><p>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</p><div class="language-"><pre><code>var o1 = { a: 1 };\nvar o2 = { a: 1 };\nconsole.log(o1 == o2); // false\n</code></pre></div></li><li><p>对象有状态：对象具有状态，同一对象可能处于不同状态之下。</p><div class="language-"><pre><code>var o = { \n  d: 1,\n  f() {\n      console.log(this.d);\n  }    \n};\n</code></pre></div><p>在 JavaScript 中，对象的状态和行为其实都被抽象为了属性</p></li><li><p>对象具有行为：即对象的状态，可能因为它的行为产生变迁。</p></li></ol><h2 id="对象的两类属性"><a class="header-anchor" href="#对象的两类属性" aria-hidden="true">#</a> 对象的两类属性</h2><p>对 JavaScript 来说，属性并非只是简单的名称和值，JavaScript 用一组特征（attribute）来描述属性（property）。</p><h2 id="数据属性"><a class="header-anchor" href="#数据属性" aria-hidden="true">#</a> 数据属性</h2><p>在大多数情况下，我们只关心数据属性的值即可。</p><ul><li>value：就是属性的值。</li><li>writable：决定属性能否被赋值。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul><h2 id="访问器（getter-setter）属性"><a class="header-anchor" href="#访问器（getter-setter）属性" aria-hidden="true">#</a> 访问器（getter/setter）属性</h2><ul><li>getter：函数或 undefined，在取属性值时被调用。</li><li>setter：函数或 undefined，在设置属性值时被调用。</li><li>enumerable：决定 for in 能否枚举该属性。</li><li>configurable：决定该属性能否被删除或者改变特征值。</li></ul><p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p><blockquote><p>我们通常用于定义属性的代码会产生数据属性，其中的 writable、enumerable、configurable 都默认为 true。</p></blockquote><h4 id="使用getownpropertydescriptor查看数据属性"><a class="header-anchor" href="#使用getownpropertydescriptor查看数据属性" aria-hidden="true">#</a> 使用getOwnPropertyDescriptor查看数据属性</h4><div class="language-"><pre><code>var o = { a: 1 };\no.b = 2;\n//a和b皆为数据属性\nObject.getOwnPropertyDescriptor(o,&quot;a&quot;) // {value: 1, writable: true, enumerable: true, configurable: true}\nObject.getOwnPropertyDescriptor(o,&quot;b&quot;) // {value: 2, writable: true, enumerable: true, configurable: true}\n</code></pre></div><h4 id="使用object-defineproperty改变数据属性"><a class="header-anchor" href="#使用object-defineproperty改变数据属性" aria-hidden="true">#</a> 使用Object.defineProperty改变数据属性</h4><div class="language-"><pre><code>var o = { a: 1 };\nObject.defineProperty(o, &quot;b&quot;, {value: 2, writable: false, enumerable: false, configurable: true});\n//a和b都是数据属性，但特征值变化了\nObject.getOwnPropertyDescriptor(o,&quot;a&quot;); // {value: 1, writable: true, enumerable: true, configurable: true}\nObject.getOwnPropertyDescriptor(o,&quot;b&quot;); // {value: 2, writable: false, enumerable: false, configurable: true}\no.b = 3;\nconsole.log(o.b); // 2\n</code></pre></div><p>使用 get 和 set 关键字来创建访问器属性</p><div class="language-"><pre><code>var o = { get a() { return 1 } };\nconsole.log(o.a); // 1\n</code></pre></div><p>访问器属性跟数据属性不同，每次访问属性都会执行 getter 或者 setter 函数。这里我们的 getter 函数返回了 1，所以 o.a 每次都得到 1。</p><h2 id="对象分类"><a class="header-anchor" href="#对象分类" aria-hidden="true">#</a> 对象分类</h2><ul><li>宿主对象（host Objects）：由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</li><li>内置对象（Built-in Objects）：由 JavaScript 语言提供的对象。 <ul><li>固有对象（Intrinsic Objects ）：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</li><li>原生对象（Native Objects）：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</li><li>普通对象（Ordinary Objects）：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</li></ul></li></ul><h3 id="宿主对象"><a class="header-anchor" href="#宿主对象" aria-hidden="true">#</a> 宿主对象</h3><p>JavaScript 宿主对象千奇百怪，但是前端最熟悉的无疑是浏览器环境中的宿主了。</p><p>在浏览器环境中，我们都知道全局对象是 window，window 上又有很多属性，如 document。实际上，这个全局对象 window 上的属性，一部分来自 JavaScript 语言，一部分来自浏览器环境。</p><p>宿主对象也分为固有的和用户可创建的两种，比如 document.createElement 就可以创建一些 DOM 对象。</p><h3 id="内置对象·固有对象"><a class="header-anchor" href="#内置对象·固有对象" aria-hidden="true">#</a> 内置对象·固有对象</h3><p>固有对象是由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</p><p><a href="https://262.ecma-international.org/9.0/#sec-well-known-intrinsic-objects" target="_blank" rel="noopener noreferrer">固有对象链接表</a></p><h4 id="小实验：获取全部-javascript-固有对象"><a class="header-anchor" href="#小实验：获取全部-javascript-固有对象" aria-hidden="true">#</a> 小实验：获取全部 JavaScript 固有对象</h4><p>我们从 JavaScript 标准中可以找到全部的 JavaScript 对象定义。JavaScript 语言规定了全局对象的属性。</p><p>三个值：Infinity、NaN、undefined。</p><p>九个函数：</p><p>eval isFinite、isNaN、parseFloat、parseInt、decodeURI 、decodeURIComponent、 encodeURI、encodeURIComponent</p><p>一些构造器：Array、Date、RegExp、Promise、Proxy、Map、WeakMap、Set、WeakSet、Function、Boolean、String、Number、Symbol、Object、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError、ArrayBuffer、SharedArrayBuffer、DataView、Typed Array、Float32Array、Float64Array、Int8Array、Int16Array、Int32Array、UInt8Array、UInt16Array、UInt32Array、UInt8ClampedArray。</p><p>四个用于当作命名空间的对象：Atomics、JSON、Math、Reflect</p><div class="language-"><pre><code>var set = new Set();\nvar objects = [\n    eval,\n    isFinite,\n    isNaN,\n    parseFloat,\n    parseInt,\n    decodeURI,\n    decodeURIComponent,\n    encodeURI,\n    encodeURIComponent,\n    Array,\n    Date,\n    RegExp,\n    Promise,\n    Proxy,\n    Map,\n    WeakMap,\n    Set,\n    WeakSet,\n    Function,\n    Boolean,\n    String,\n    Number,\n    Symbol,\n    Object,\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError,\n    URIError,\n    ArrayBuffer,\n    SharedArrayBuffer,\n    DataView,\n    Float32Array,\n    Float64Array,\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Uint8ClampedArray,\n    Atomics,\n    JSON,\n    Math,\n    Reflect];\nobjects.forEach(o =&gt; set.add(o));\n\nfor(var i = 0; i &lt; objects.length; i++) {\n    var o = objects[i]\n    for(var p of Object.getOwnPropertyNames(o)) {\n        var d = Object.getOwnPropertyDescriptor(o, p)\n        if( (d.value !== null &amp;&amp; typeof d.value === &quot;object&quot;) || (typeof d.value === &quot;function&quot;))\n            if(!set.has(d.value))\n                set.add(d.value), objects.push(d.value);\n        if( d.get )\n            if(!set.has(d.get))\n                set.add(d.get), objects.push(d.get);\n        if( d.set )\n            if(!set.has(d.set))\n                set.add(d.set), objects.push(d.set);\n    }\n}\n</code></pre></div><h3 id="内置对象·原生对象"><a class="header-anchor" href="#内置对象·原生对象" aria-hidden="true">#</a> 内置对象·原生对象</h3><p>我们把 JavaScript 中，能够通过语言本身的构造器创建的对象称作原生对象。在 JavaScript 标准中，提供了 30 多个构造器。按照我的理解，按照不同应用场景，我把原生对象分成了以下几个种类。</p><p><a data-fancybox title="img" href="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png"><img src="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png" alt="img"></a></p><p>通过这些构造器，我们可以用 new 运算创建新的对象，所以我们把这些对象称作原生对象。</p><p>几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。</p><p>这些构造器创建的对象多数使用了私有字段, 例如：</p><ul><li>Error: [[ErrorData]]</li><li>Boolean: [[BooleanData]]</li><li>Number: [[NumberData]]</li><li>Date: [[DateValue]]</li><li>RegExp: [[RegExpMatcher]]</li><li>Symbol: [[SymbolData]]Map: [[MapData]]</li></ul><p>这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“特权对象”。</p><h2 id="函数对象与构造器对象"><a class="header-anchor" href="#函数对象与构造器对象" aria-hidden="true">#</a> 函数对象与构造器对象</h2><blockquote><p>用对象来模拟函数与构造器</p></blockquote><h4 id="函数对象，具有-call-私有字段的对象"><a class="header-anchor" href="#函数对象，具有-call-私有字段的对象" aria-hidden="true">#</a> 函数对象，具有[[call]]私有字段的对象</h4><blockquote><p>[[call]]私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换</p></blockquote><p>任何对象只需要实现[[call]]，它就是一个函数对象，可以去作为函数被调用</p><h4 id="构造器对象，具有私有字段-construct-的对象"><a class="header-anchor" href="#构造器对象，具有私有字段-construct-的对象" aria-hidden="true">#</a> 构造器对象，具有私有字段[[construct]]的对象</h4><p>任何对象实现[[construct]]，它就是一个构造器对象，可以作为构造器被调用</p><p>用 function 关键字创建的函数必定同时是函数和构造器</p><p>ES6 之后 =&gt; 语法创建的函数仅仅是函数，它们无法被当作构造器使用</p><div class="language-"><pre><code>new (a =&gt; 0) // error\n</code></pre></div><p>对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]]和[[construct]]行为总是相似的，它们执行同一段代码。</p><div class="language-"><pre><code>function f(){\n    return 1;\n}\nvar v = f(); //把f作为函数调用\nvar o = new f(); //把f作为构造器调用\n</code></pre></div><p>它们[[construct]]的执行过程如下：</p><ul><li>以 Object.prototype 为原型创建一个新对象；</li><li>以新对象为 this，执行函数的[[call]]；</li><li>如果[[call]]的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li></ul><p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p><div class="language-"><pre><code>function cls(){    this.a = 100; //除了函数内，其它地方都无法访问，实现了私有    return {        getValue:() =&gt; this.a    }}var o = new cls;o.getValue(); //100//a在外面永远无法访问到\n</code></pre></div><h3 id="特殊行为的对象"><a class="header-anchor" href="#特殊行为的对象" aria-hidden="true">#</a> 特殊行为的对象</h3><blockquote><p>在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。</p></blockquote><ul><li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li><li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li><li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li><li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。模块的</li><li>namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><li>bind 后的 function：跟原来的函数相关联。</li></ul>',64);n.render=function(a,t,n,i,o,c){return r(),e("div",null,[l])};export default n;export{t as __pageData};
