import{g as n,f as t,E as o}from"./common-d6bd45c0.js";const e='{"title":"ios 下 setTimeOut 中不执行 window.open","frontmatter":{},"headers":[{"level":2,"title":"ios 下 setTimeOut 中不执行 window.open","slug":"ios-下-settimeout-中不执行-window-open"},{"level":2,"title":"微信h5 通过百度地图获取城市","slug":"微信h5-通过百度地图获取城市"}],"relativePath":"docs/work/h5.md","lastUpdated":1645369066141.923}';var i={};const r=o('<h2 id="ios-下-settimeout-中不执行-window-open"><a class="header-anchor" href="#ios-下-settimeout-中不执行-window-open" aria-hidden="true">#</a> ios 下 setTimeOut 中不执行 window.open</h2><p>ios 根据用户的行为来判定操作是不是属于流氓操作,如果是用户自己的动作触发的window.open就不会被阻止，比如写在onclick事件中，但如果是代码自动触发就会被阻止的。</p><p>解决方案，使用 window.location.href 跳转（在微信上ios好像还是有问题，建议增加弹窗确认跳转），或者为事件添加点击事件</p><h2 id="微信h5-通过百度地图获取城市"><a class="header-anchor" href="#微信h5-通过百度地图获取城市" aria-hidden="true">#</a> 微信h5 通过百度地图获取城市</h2><p>直接使用百度地图api 的 getLocalCity 在手机上获取的城市一直都是全国 使用 百度地图api获取经纬度 在微信上会直接重定向到百度域名</p><p>最终方案：使用原生获取经纬度，再转换成百度地图的坐标（不转换直接使用变量无法解析），再解析城市</p><div class="language-"><pre><code>import BMap from &#39;BMap&#39;\nimport { Toast } from &#39;vant&#39;\n// 返回的定位结果\nexport type LocationResult = {\n  cityName: string\n  cityCode: string | number\n}\n// 经纬度，等位置信\ninterface PositionOptions {\n  coords: {\n    latitude: number\n    longitude: number\n  }\n}\n\ninterface ICITY_LIST {\n  code: string\n  name: string\n}\n\nexport function getCity() {\n  return new Promise&lt;LocationResult&gt;((resolve, reject) =&gt; {\n    const geoShowPosition = (position: PositionOptions) =&gt; {\n      if (position.coords.latitude) {\n        const { latitude, longitude } = position?.coords\n        // 坐标转换\n        const pt = new BMap.Point(latitude, longitude)\n        const convertor = new BMap.Convertor()\n        const pointArr = []\n        pointArr.push(pt)\n        convertor.translate(pointArr, 1, 5, translateCallback)\n      } else {\n        reject()\n      }\n    }\n\n    function translateCallback(data: { points: { lat: number; lng: number }[] }) {\n      if (data.points &amp;&amp; data.points.length &gt; 0) {\n        const myGeo = new BMap.Geocoder()\n        const pt = new BMap.Point(data.points[0].lat, data.points[0].lng)\n        // 解析城市\n        myGeo.getLocation(pt, (result: { addressComponents: { city: string } }) =&gt; {\n          const testJson = require(&#39;../constant/city.json&#39;) as ICITY_LIST[]\n          let cityCode = &#39;0&#39;\n          testJson.forEach(item =&gt; {\n            if (item.name === result?.addressComponents?.city) {\n              cityCode = item.code\n              return\n            }\n          })\n          resolve({\n            cityName: result?.addressComponents?.city,\n            cityCode\n          })\n        })\n      }\n    }\n\n    const geoShowError = (error: { code: number; message: string }) =&gt; {\n      Toast.fail(`getPosError:${error.code},${navigator.geolocation},${error.message}`)\n      reject()\n    }\n\n    navigator.geolocation.getCurrentPosition(geoShowPosition, geoShowError)\n  })\n}\n</code></pre></div>',7);i.render=function(o,e,i,s,a,c){return t(),n("div",null,[r])};export default i;export{e as __pageData};
