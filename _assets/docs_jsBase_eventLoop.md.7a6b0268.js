import{g as e,f as n,E as o}from"./common-d6bd45c0.js";const t='{"title":"执行顺序","frontmatter":{},"headers":[{"level":2,"title":"执行顺序","slug":"执行顺序"}],"relativePath":"docs/jsBase/eventLoop.md","lastUpdated":1643114720048.344}';var s={};const l=o('<p>event loop 分为宏任务跟微任务，是单线程</p><p>宏任务：就是由宿主（node,浏览器）主动发起的 script,settimeout,setInterval...</p><p>微任务：就是由javascript引擎发起，就是由代码产生的，也就是只有promise的then跟process.nexktick</p><p><a data-fancybox title="image.png" href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b2b30bf679342379cd9902ee5910714~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b2b30bf679342379cd9902ee5910714~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><h2 id="执行顺序"><a class="header-anchor" href="#执行顺序" aria-hidden="true">#</a> 执行顺序</h2><p>1.先执行script中的同步代码</p><p>2.同步代码执行完毕，执行异步代码中的微任务，微任务优先于宏任务，即then，nextick,promise这些要比settimeout这些先执行</p><p>3.执行异步中的所有微任务（不管顺序，只要不遇到宏任务）执行完毕后，在执行过程中，会把遇到的宏任务添加到‘宏任务栈’中</p><p>4.执行‘宏任务栈’，先添加的先执行，在里面还是先执行微任务，遇到宏任务又添加到‘宏任务栈’中，于此循环往复，直到全部执行完毕</p><blockquote><p>简单总结一句话就是：同步任务结束后，先处理微任务，然后处理宏任务，宏观任务内部处理重复上述动作。如果把整体代码块算进去，其实是先执行宏任务，再执行宏任务里面的微任务</p></blockquote><h4 id="微任务始终先于宏任务"><a class="header-anchor" href="#微任务始终先于宏任务" aria-hidden="true">#</a> 微任务始终先于宏任务</h4><div class="language-"><pre><code>setTimeout(()=&gt;{\n    console.log(&quot;c5&quot;)\n    setTimeout(()=&gt;{\n        console.log(&quot;c9&quot;)\n        new Promise(function(resolve, reject){\n           resolve()\n        }).then(() =&gt;{\n            console.log(&quot;c10&quot;)\n        })\n    }, 0)\n    new Promise(function(resolve, reject){\n           resolve()\n        }).then(() =&gt;{\n            console.log(&quot;c6&quot;)\n        })\n}, 0)\nvar r = new Promise(function(resolve, reject){\n    console.log(&quot;c1&quot;)\n    resolve()\n});\nr.then(() =&gt; { \n    var begin = Date.now();\n    while(Date.now() - begin &lt; 1000);\n    console.log(&quot;c2&quot;) \n    new Promise(function(resolve, reject){\n        resolve()\n    }).then(() =&gt;{\n        console.log(&quot;c3&quot;);\n        setTimeout(()=&gt; console.log(&quot;c7&quot;), 0)\n        new Promise(function(resolve, reject){\n           resolve()\n        }).then(() =&gt;{\n            console.log(&quot;c4&quot;)\n            setTimeout(()=&gt;{        \n                setTimeout(()=&gt;{\n                 console.log(&quot;c11&quot;)\n                }, 0)\n                 console.log(&quot;c8&quot;)\n            }, 0)\n        })\n    }) \n});\n\n执行顺序：c1 - c11\n</code></pre></div><div class="language-"><pre><code>console.log(&#39;start&#39;);\n\nsetTimeout(() =&gt; {\nconsole.log(&#39;s1&#39;);\n    new Promise(resolve =&gt; {\n        console.log(&#39;p2&#39;);\n        resolve(true);\n    }).then(() =&gt; {\n         console.log(&#39;then2&#39;);\n    });\n});\n\nfunction task() {\n    console.log(&#39;task&#39;);\n}\n\nnew Promise(resolve =&gt; {\n    console.log(&#39;p1&#39;);\n    resolve(true);\n}).then(() =&gt; {\n    console.log(&#39;then&#39;);\n});\n\ntask();\n\nconsole.log(&#39;end&#39;);\n\n执行顺序：start p1 task end (同步任务) then (微任务) s1(宏任务) p2 then2(宏任务中的微任务，循环) \n\n现实中的场景：\nsettimeout(()=&gt;{\n    console.log(&quot;1&quot;)\n},2000)\nsettimeout(()=&gt;{\n    console.log(&quot;2&quot;)\n},1000)\n//请求的同步代码\n{\n    2000毫秒后完成\n}\n这个时候如何输出，两秒后同时输出2，1，2比1快\n</code></pre></div>',13);s.render=function(o,t,s,c,r,i){return n(),e("div",null,[l])};export default s;export{t as __pageData};
