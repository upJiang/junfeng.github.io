import{g as n,f as e,E as a}from"./common-d6bd45c0.js";const o='{"title":"五种绑定","frontmatter":{},"headers":[{"level":2,"title":"五种绑定","slug":"五种绑定"},{"level":3,"title":"默认绑定","slug":"默认绑定"},{"level":3,"title":"隐式绑定","slug":"隐式绑定"},{"level":3,"title":"显示绑定","slug":"显示绑定"},{"level":3,"title":"new绑定","slug":"new绑定"},{"level":3,"title":"箭头函数","slug":"箭头函数"}],"relativePath":"docs/jsBase/bind.md","lastUpdated":1627826543668.5464}';var i={};const l=a('<h2 id="五种绑定"><a class="header-anchor" href="#五种绑定" aria-hidden="true">#</a> 五种绑定</h2><p>方式:默认绑定、隐式绑定、显示绑定、new绑定、箭头函数绑定</p><p>优先级：显式绑定 &gt; 隐式绑定 &gt; 默认绑定 new绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h3 id="默认绑定"><a class="header-anchor" href="#默认绑定" aria-hidden="true">#</a> 默认绑定</h3><blockquote><p>当函数调用没有任何前缀的情况下，this在非严格模式下指向window，在严格模式下指向undefined，在严格模式下调用不在严格模式下的函数，并不影响this的返回</p></blockquote><div class="language-"><pre><code>function fn1() {\n    console.log(this); //window\n};\nfunction fn2() {\n    &quot;use strict&quot;;\n    console.log(this); //undefined\n};\nvar name = &#39;听风是风&#39;;\nfunction fn3() {\n    console.log(this); //window\n};\n(function () {\n    &quot;use strict&quot;;\n    fn3();\n}());\n</code></pre></div><h3 id="隐式绑定"><a class="header-anchor" href="#隐式绑定" aria-hidden="true">#</a> 隐式绑定</h3><h4 id="_1-如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上"><a class="header-anchor" href="#_1-如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上" aria-hidden="true">#</a> 1. 如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上</h4><div class="language-"><pre><code>function fn() {\n    console.log(this.name);\n};\nlet obj = {\n    name: &#39;听风是风&#39;,\n    func: fn\n};\nobj.func() //听风是风\n</code></pre></div><h4 id="_2-如果函数调用前存在多个对象，this指向距离调用自己最近的对象"><a class="header-anchor" href="#_2-如果函数调用前存在多个对象，this指向距离调用自己最近的对象" aria-hidden="true">#</a> 2. 如果函数调用前存在多个对象，this指向距离调用自己最近的对象</h4><div class="language-"><pre><code>function fn() {\n    console.log(this.name);\n};\nlet obj = {\n    name: &#39;行星飞行&#39;,\n    func: fn,\n};\nlet obj1 = {\n    name: &#39;听风是风&#39;,\n    o: obj\n};\nobj1.o.func() //行星飞行\n</code></pre></div><h4 id="隐式丢失"><a class="header-anchor" href="#隐式丢失" aria-hidden="true">#</a> 隐式丢失</h4><ol><li>作为参数传递以及变量赋值</li></ol><div class="language-"><pre><code>var name = &#39;行星飞行&#39;;\nlet obj = {\n    name: &#39;听风是风&#39;,\n    fn: function () {\n        console.log(this.name);\n    }\n};\nfunction fn1(param) {\n    param();\n};\nfn1(obj.fn);//行星飞行\n例子中我们将 obj.fn 也就是一个函数传递进 fn1 中执行，这里只是单纯传递了一个函数而已，this并没有跟函数绑在一起，所以this丢失这里指向了window。\n</code></pre></div><ol start="2"><li>变量赋值，其实本质上与传参相同</li></ol><div class="language-"><pre><code>var name = &#39;行星飞行&#39;;\nlet obj = {\n    name: &#39;听风是风&#39;,\n    fn: function () {\n        console.log(this.name);\n    }\n};\nlet fn1 = obj.fn;\nfn1(); //行星飞行\n</code></pre></div><p>3.隐式绑定丢失并不是都会指向全局对象</p><div class="language-"><pre><code>var name = &#39;行星飞行&#39;;\nlet obj = {\n    name: &#39;听风是风&#39;,\n    fn: function () {\n        console.log(this.name);\n    }\n};\nlet obj1 = {\n    name: &#39;时间跳跃&#39;\n}\nobj1.fn = obj.fn;\nobj1.fn(); //时间跳跃\n虽然丢失了 obj 的隐式绑定，但是在赋值的过程中，又建立了新的隐式绑定，这里this就指向了对象 obj1。\n</code></pre></div><h3 id="显示绑定"><a class="header-anchor" href="#显示绑定" aria-hidden="true">#</a> 显示绑定</h3><blockquote><p>通过call、apply以及bind方法改变this的行为</p></blockquote><div class="language-"><pre><code>let obj1 = {\n    name: &#39;听风是风&#39;\n};\nlet obj2 = {\n    name: &#39;时间跳跃&#39;\n};\nlet obj3 = {\n    name: &#39;echo&#39;\n}\nvar name = &#39;行星飞行&#39;;\n\nfunction fn() {\n    console.log(this.name);\n};\nfn(); //行星飞行\nfn.call(obj1); //听风是风\nfn.apply(obj2); //时间跳跃\nfn.bind(obj3)(); //echo ，因为bind非立即执行，详情参考笔记的this指向call，apply，bind\n</code></pre></div><blockquote><p>注意，如果在使用call之类的方法改变this指向时，指向参数提供的是null或者undefined，那么 this 将指向全局对象。</p></blockquote><div class="language-"><pre><code>let obj1 = {\n    name: &#39;听风是风&#39;\n};\nlet obj2 = {\n    name: &#39;时间跳跃&#39;\n};\nvar name = &#39;行星飞行&#39;;\nfunction fn() {\n    console.log(this.name);\n};\nfn.call(undefined); //行星飞行\nfn.apply(null); //行星飞行\nfn.bind(undefined)(); //行星飞行\n</code></pre></div><h3 id="new绑定"><a class="header-anchor" href="#new绑定" aria-hidden="true">#</a> new绑定</h3><p>new执行了什么<br> (1) 创建一个新对象<br> (2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） <br> (3) 执行构造函数中的代码（为这个新对象添加属性） <br> (4) 返回新对象<br></p><div class="language-"><pre><code>function Fn(){\n    this.name = &#39;听风是风&#39;;\n};\nlet echo = new Fn(); //this将指向新对象echo上\necho.name//听风是风\n</code></pre></div><h3 id="箭头函数"><a class="header-anchor" href="#箭头函数" aria-hidden="true">#</a> 箭头函数</h3><p>准确来说，箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁。</p>',28);i.render=function(a,o,i,t,d,s){return e(),n("div",null,[l])};export default i;export{o as __pageData};
