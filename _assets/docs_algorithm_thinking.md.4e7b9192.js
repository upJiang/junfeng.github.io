import{g as n,f as e,E as s}from"./common-d6bd45c0.js";const t='{"title":"循环下的递归执行","frontmatter":{},"headers":[{"level":2,"title":"循环下的递归执行","slug":"循环下的递归执行"},{"level":2,"title":"全排列问题-递归思想","slug":"全排列问题-递归思想"},{"level":2,"title":"组合问题：变化的“坑位”，不变的“套路”","slug":"组合问题：变化的“坑位”，不变的“套路”"},{"level":2,"title":"限定组合问题：及时回溯，即为“剪枝”","slug":"限定组合问题：及时回溯，即为“剪枝”"},{"level":2,"title":"递归与回溯问题——解题模板总结","slug":"递归与回溯问题——解题模板总结"},{"level":3,"title":"什么时候用","slug":"什么时候用"},{"level":3,"title":"怎么用","slug":"怎么用"}],"relativePath":"docs/algorithm/thinking.md","lastUpdated":1646060351654.8108}';var a={};const i=s('<p>“思想”并不是一坨剪不断理还乱、学了只能用来吹水的虚无概念。“思想”本质上就是套路，而且是普适性非常强的套路</p><p>在研究递归问题时，我觉得很有必要先了解 for 循环里面的递归是怎么一个执行顺序，否则直接往下学会很懵逼，看不懂代码</p><h2 id="循环下的递归执行"><a class="header-anchor" href="#循环下的递归执行" aria-hidden="true">#</a> 循环下的递归执行</h2><p>先看一段代码：</p><div class="language-"><pre><code>let num = 1\nfunction cycle(){\n    console.log(&quot;111&quot;)\n    if(num&lt;3){\n        num++\n        console.log(&quot;222&quot;)\n        cycle()\n        console.log(&quot;num&quot;,num)\n    }\n    console.log(&quot;最后执行&quot;)\n}\ncycle()\n\n执行结果：\n111\n222\n111\n222\n111\n最后执行\nnum 3\n最后执行\nnum 3\n最后执行\n</code></pre></div><p>第二段代码</p><div class="language-"><pre><code>function cycle(num){\n    if(num === 3){\n         return   \n    }\n    console.log(&quot;111&quot;)\n    for(let i=0;i&lt;3;i++){\n        console.log(&quot;222&quot;)\n        cycle(num+1)\n        console.log(&quot;333&quot;)\n    }\n    console.log(&quot;最后执行&quot;)\n}\ncycle(0)\n\n这个执行就是下面解法的过程\n</code></pre></div><p>递归是一个同步执行的过程，如果实在看不懂，就把递归函数展开研究。。。</p><h2 id="全排列问题-递归思想"><a class="header-anchor" href="#全排列问题-递归思想" aria-hidden="true">#</a> 全排列问题-递归思想</h2><blockquote><p>题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。</p></blockquote><div class="language-"><pre><code>示例：   \n输入: [1,2,3]\n输出: [\n[1,2,3],\n[1,3,2],\n[2,1,3],\n[2,3,1],\n[3,1,2],\n[3,2,1]\n]\n</code></pre></div><p>这题的结果数量应该就是 m*(m-1) = 6</p><p>我们这样去思考，题目中不变的是“坑位”，我们手里有三张牌，我们要把牌发到坑位中。第一个坑位有三张牌能选，第二个坑位有两张，第三个坑位没得选。<br><a data-fancybox title="img" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a215aa6c68~tplv-t2oaga2asx-watermark.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a215aa6c68~tplv-t2oaga2asx-watermark.awebp" alt="img"></a></p><p>我们把它装换成一棵树看看：<br><a data-fancybox title="img" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21d81055e~tplv-t2oaga2asx-watermark.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a21d81055e~tplv-t2oaga2asx-watermark.awebp" alt="img"></a></p><p>现在来看，这个问题不就是一个 DFS 问题，解题思路就是递归。</p><p><a data-fancybox title="image.png" href="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49133bf5ae984a3c8ba5cb9a5bb37252~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49133bf5ae984a3c8ba5cb9a5bb37252~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p><a href="https://www.bilibili.com/video/av795444055?from=search&amp;seid=11104532396806146862&amp;spm_id_from=333.337.0.0" target="_blank" rel="noopener noreferrer">如果实在还是不懂可以看这个视频</a></p><div class="language-"><pre><code>const permute = (nums)=&gt;{\n    let res = [] // 结果数组\n    dfs([]) // 传入的 path 用来接收当前的排序内容\n    function dfs(path){\n        // 当 path 的长度等于数组 nums 的长度时，则 把结果放到 res 中\n        if(path.length === nums.length){\n            res.push([...path])  // 将 path 结果深拷贝放入 res 中，不深拷贝的话后面结果都是同一个地址\n            return\n        }\n\n        // 遍历 nums 数组，去给 path 赋值\n        for(let i = 0;i&lt; nums.length;i++){\n            // 当 path 中存在遍历值，则跳出 continue\n            if(path.includes(nums[i])){\n                continue\n            }\n\n            // 如果 path 不存在当前遍历值\n            path.push(nums[i])  // 将当前遍历值放到 path 中\n\n            // 然后递归调用 dfs，将 path 传入，只有当 path 的长度满足要求了才 return\n            dfs(path)\n            // 这个语句其实就是回溯，此时已经获取到了一个结果 path\n            // 当递归执行完了，他会继续执行之前入栈后的代码（path.pop()），执行多少次，得看它被入栈了多少次，这里取决于 path.includes(nums[i])\n            // 此时结点就是在最后一层，它需要返回到第二层甚至是第一层\n            // 至于返回到那一层取决于 pop 掉一个值后，当前的遍历循环中是否满足 path.includes(nums[i]，不满足则继续回溯，继续 pop\n            // 就相当于二叉树的左序遍历。\n            path.pop()\n        }\n    }\n    // 返回结果\n    return res\n}\n</code></pre></div><p>我们也可以使用一个 Map 去记录已经取过的值，避免重复</p><div class="language-"><pre><code>const permute = function(nums) {\n  // 缓存数组的长度\n  const len = nums.length\n  // curr 变量用来记录当前的排列内容\n  const curr = []\n  // res 用来记录所有的排列顺序\n  const res = []\n  // visited 用来避免重复使用同一个数字\n  const visited = {}\n  // 定义 dfs 函数，入参是坑位的索引（从 0 计数）\n  function dfs(nth) {\n      // 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回\n      if(nth === len) {\n          // 此时前 len 个坑位已经填满，将对应的排列记录下来\n          res.push(curr.slice())\n          return \n      }\n      // 检查手里剩下的数字有哪些\n      for(let i=0;i&lt;len;i++) {\n          // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”\n          if(!visited[nums[i]]) {\n              // 给 nums[i] 打个“已用过”的标\n              visited[nums[i]] = 1\n              // 将nums[i]推入当前排列\n              curr.push(nums[i])\n              // 基于这个排列继续往下一个坑走去\n              dfs(nth+1) \n              // nums[i]让出当前坑位\n              curr.pop()\n              // 下掉“已用过”标识\n              visited[nums[i]] = 0\n          }\n      }\n  }\n  // 从索引为 0 的坑位（也就是第一个坑位）开始 dfs\n  dfs(0)\n  return res\n};\n</code></pre></div><h2 id="组合问题：变化的“坑位”，不变的“套路”"><a class="header-anchor" href="#组合问题：变化的“坑位”，不变的“套路”" aria-hidden="true">#</a> 组合问题：变化的“坑位”，不变的“套路”</h2><blockquote><p>题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。</p></blockquote><p>示例: 输入: nums = [1,2,3]<br> 输出:<br> [ [3], [1], [2],[1,3],[2,3],[1,2],[1,2,3],[] ]<br></p><p>跟上题对比：多了一个取不去取值的判断，但是不判断顺序，也没有限制取的个数</p><p><a data-fancybox title="img" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a25410cf07~tplv-t2oaga2asx-watermark.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a25410cf07~tplv-t2oaga2asx-watermark.awebp" alt="img"></a></p><div class="language-"><pre><code>// 入参是一个数组\nconst subsets = function(nums) {\n    // 初始化结果数组\n    const res = []   \n    // 缓存数组长度\n    const len = nums.length\n    // 初始化组合数组\n    const subset = []\n    // 进入 dfs\n    dfs(0)  \n\n    // 定义 dfs 函数，入参是 nums 中的数字索引\n    function dfs(index) {\n        // 每次进入，都意味着组合内容更新了一次，故直接推入结果数组\n        res.push(subset.slice())\n        // 从当前数字的索引开始，遍历 nums\n        for(let i=index;i&lt;len;i++) {\n            subset.push(nums[i]) \n            dfs(i+1)\n            subset.pop()\n        }\n    }\n    // 返回结果数组\n    return res \n};\n\n看不懂把 dfs 展开\n  function dfs(index) {\n        res.push(subset.slice())\n        for(let i=index;i&lt;len;i++) { 三次 pop 变成 [],i=1,又继续往下走;两次pop又变成[],i=2\n            subset.push(nums[i]) i=0,结果 [1];第二遍往下走 i=1,结果 [2];第三遍往下走 i=2.结果[3]\n            {\n                res.push(subset.slice())\n                for(let i=index;i&lt;len;i++) {  两次 pop 变成 [1]，i = 2，所以结果[1,3];第二遍往下走 i=2,结果 [2,3]\n                    subset.push(nums[i]) i=1, 结果 [1,2]\n                    {\n                        res.push(subset.slice())\n                        for(let i=index;i&lt;len;i++) {\n                            subset.push(nums[i]) i=2 结果 [1,2,3]\n                            {\n                                res.push(subset.slice())\n                            }\n                            subset.pop() pop:变成 [1,2]\n                        }\n                    }\n                    subset.pop() pop:变成 [1]\n                }\n                subset.pop() pop:变成 []\n            }\n            subset.pop()\n        }\n    }\n</code></pre></div><h2 id="限定组合问题：及时回溯，即为“剪枝”"><a class="header-anchor" href="#限定组合问题：及时回溯，即为“剪枝”" aria-hidden="true">#</a> 限定组合问题：及时回溯，即为“剪枝”</h2><blockquote><p>题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。</p></blockquote><div class="language-"><pre><code>示例: 输入: n = 4, k = 2\n输出:\n[\n[2,4],\n[3,4],\n[2,3],\n[1,2],\n[1,3],\n[1,4],\n]\n</code></pre></div><p><a data-fancybox title="img" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a254223576~tplv-t2oaga2asx-watermark.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/3/171da9a254223576~tplv-t2oaga2asx-watermark.awebp" alt="img"></a></p><p>跟第二题相比，只是限定了数组的大小，在出结果那里限制一些临界条件即可</p><div class="language-"><pre><code>const combine = function(n, k) {\n   // 初始化结果数组\n    const res = []   \n    // 初始化组合数组\n    const subset = []\n    // 进入 dfs，起始数字是1\n    dfs(1)  \n\n    // 定义 dfs 函数，入参是当前遍历到的数字\n    function dfs(index) {\n        if(subset.length === k) {\n            res.push(subset.slice())\n            return \n        }\n        // 从当前数字的值开始，遍历 index-n 之间的所有数字\n        for(let i=index;i&lt;=n;i++) {\n            // 这是当前数字存在于组合中的情况\n            subset.push(i) \n            // 基于当前数字存在于组合中的情况，进一步 dfs\n            dfs(i+1)\n            // 这是当前数字不存在与组合中的情况\n            subset.pop()\n        }\n    }\n    // 返回结果数组\n    return res \n};\n</code></pre></div><h2 id="递归与回溯问题——解题模板总结"><a class="header-anchor" href="#递归与回溯问题——解题模板总结" aria-hidden="true">#</a> 递归与回溯问题——解题模板总结</h2><h3 id="什么时候用"><a class="header-anchor" href="#什么时候用" aria-hidden="true">#</a> 什么时候用</h3><p>看两个特征：</p><ul><li>题目中暗示了一个或多个解，并且要求我们详尽地列举出每一个解的内容时，一定要想到 DFS、想到递归回溯。</li><li>题目经分析后，可以转化为树形逻辑模型求解。</li></ul><h3 id="怎么用"><a class="header-anchor" href="#怎么用" aria-hidden="true">#</a> 怎么用</h3><p>一个模型——树形逻辑模型；两个要点——递归式和递归边界。<br> 树形逻辑模型的构建，关键在于找“坑位”，一个坑位就对应树中的一层，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。至于递归边界，要么在题目中约束得非常清楚、要么默认为“坑位”数量的边界。 <br> 用伪代码总结一下编码形式，大部分的题解都符合以下特征： <br></p><div class="language-"><pre><code>function xxx(入参) {\n  前期的变量定义、缓存等准备工作 \n  \n  // 定义路径栈\n  const path = []\n  \n  // 进入 dfs\n  dfs(起点) \n  \n  // 定义 dfs\n  dfs(递归参数) {\n    if(到达了递归边界) {\n      结合题意处理边界逻辑，往往和 path 内容有关\n      return   \n    }\n    \n    // 注意这里也可能不是 for，视题意决定\n    for(遍历坑位的可选值) {\n      path.push(当前选中值)\n      处理坑位本身的相关逻辑\n      path.pop()\n    }\n  }\n}\n</code></pre></div>',39);a.render=function(s,t,a,o,p,r){return e(),n("div",null,[i])};export default a;export{t as __pageData};
