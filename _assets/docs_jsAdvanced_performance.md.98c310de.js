import{g as e,f as t,E as c}from"./common-d6bd45c0.js";const r='{"title":"OSS对象存储和CDN","frontmatter":{},"headers":[{"level":2,"title":"OSS对象存储和CDN","slug":"oss对象存储和cdn"},{"level":2,"title":"webp 的使用","slug":"webp-的使用"},{"level":2,"title":"性能优化的一些普通点","slug":"性能优化的一些普通点"}],"relativePath":"docs/jsAdvanced/performance.md","lastUpdated":1646581973447.7112}';var a={};const i=c('<p><a data-fancybox title="img" href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c840271dc457409baa0ed1996f38ed04~tplv-k3u1fbpfcp-watermark.awebp"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c840271dc457409baa0ed1996f38ed04~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></a></p><p>可移步到重学前端的sum_性能</p><p><a href="https://juejin.cn/post/6949896020788690958" target="_blank" rel="noopener noreferrer">这篇文章对性能优化的细节讲的很好</a></p><h2 id="oss对象存储和cdn"><a class="header-anchor" href="#oss对象存储和cdn" aria-hidden="true">#</a> OSS对象存储和CDN</h2><p><strong>概念</strong><br> oss: 对象存储将数据通道(需要访问的数据)和控制通路(元数据，即索引)分离，先根据索引(也就是元数据)找到数据存储的位置，进而通过底层的存储接口来访问数据。就是用来上传资源的，并且会为我们提供一些优化方案。</p><p>cdn:CDN(Content Delivery Network)是内容分发网络。基本思路就是在网络各处部署服务节点，系统实时地根据网络流量、负载状况、服务节点到用户的响应时间等信息，自动将用户请求到导向离用户最近的节点上。目的就是让用户就近取得数据，提高响应速度。就是给我们提供一个加速，把oss资源地址加到cdn中</p><p>对象存储的核心是存储，以及计算能力(图片处理)，CDN的核心是分发，本身不会给用户提供直接操作存储的入口，所以一般是两者配合使用。对象存储里面存的就是一些图片、视频、文件等等，都是静态数据，正好适合用CDN做加速。用户要做的就是购买CDN服务，并把静态数据URL添加到CDN的加速域名列表中。</p><p>CDN主要应用于站点加速，提高网站中静态数据的访问性能，比如图片、音频、视频、静态html网页等。网站静态数据以前一般是用文件存储的形式保存，现在则主要用对象存储。以图片存储为例，<code>简单说，对象存储是存图片的，CDN是加速下载图片的</code>。对象存储+CDN，已经成为互联网应用的一个必不可少的组成部分。</p><h2 id="webp-的使用"><a class="header-anchor" href="#webp-的使用" aria-hidden="true">#</a> webp 的使用</h2><p>WebP 是由 Google 开发的一种新的图片格式，它支持有损压缩、无损压缩和透明度，压缩后的文件大小比 JPEG、PNG 等都要小。</p><p>WebP 为网络图片提供了无损和有损压缩能力，同时在有损条件下支持透明通道。据官方实验显示：无损 WebP 相比 PNG 减少26%大小；下相比JPEG减少25%~34%的大小；有损WebP也支持透明通道，大小通常约为对应 PNG 的1/3。</p><p>使用方法1：<br> 使用 <code>&lt;picture&gt;</code> 标签，<code>&lt;picture&gt;</code> 是 H5 中的一个新标签，类似 <code>&lt;video&gt;</code> 它也可以指定多个格式的资源，由浏览器选择自己支持的格式进行加载。<br></p><div class="language-"><pre><code>&lt;picture class=&quot;picture&quot;&gt;\n  &lt;source type=&quot;image/webp&quot; srcset=&quot;image.webp&quot;&gt;\n  &lt;img class=&quot;image&quot; src=&quot;image.jpg&quot;&gt;\n&lt;/picture&gt;\n</code></pre></div><p>如果浏览器不支持 WebP 格式，那么会自动使用 img 标签，如果支持就会使用 WebP 图片。并且当浏览器不支持 <code>&lt;picture&gt;</code> 标签时，也会默认使用 img 标签，图片仍然会正常展示。只不过 css 无法选取 <code>&lt;picture&gt;</code>标签，但是仍然会选取到 img 标签。<br> 这种方式兼容性还算不错，不过依然有很大的局限性，如不能作用于 css 中的图片、背景图片。</p><p>使用方法2：<br> 使用JS替换图片的URL，类似图片懒加载的原理，根据浏览器是否支持 WebP 格式，给 img 的 src 赋不同的值。<br> 具体的操作就是给浏览器一个 WebP 格式的图片，看浏览器是否能正确渲染，在这个异步的方法中根据渲染的成功与否，执行回调函数，然后将结果存储在localstorage中，避免重复检查。代码如下：</p><div class="language-"><pre><code>function checkWebp(callback) {\n  var img = new Image();\n  img.onload = function () {\n    var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0);\n    callback(result);\n  };\n  img.onerror = function () {\n    callback(false);\n  };\n  img.src = &#39;data:image/webp;base64,lAABSoBAQVXD+JaQAUkRAQCA4ADsJAAdAIBYAUAAlGRAwAA3AAEAA&#39;;\n}\n</code></pre></div><p>然后根据 checkWebp 的回调函数参数判断是否支持webp格式来决定是否替换src</p><div class="language-"><pre><code>function showImage(supWebp){\n  var imgs = Array.from(document.querySelectorAll(&#39;img&#39;));\n\n  imgs.forEach(function(i){\n    var src = i.attributes[&#39;data-src&#39;].value;\n\n\t// 如果支持则替换\n    if (supWebp){\n      src = src.replace(/\\.jpg$/, &#39;.webp&#39;);\n    }\n\n    i.src = src;\n  });\n}\n\ncheckWebp(showImage);\n</code></pre></div><p><a href="https://www.zybuluo.com/hopefrontEnd/note/1317978" target="_blank" rel="noopener noreferrer">oss方式使用webp</a></p><h2 id="性能优化的一些普通点"><a class="header-anchor" href="#性能优化的一些普通点" aria-hidden="true">#</a> 性能优化的一些普通点</h2><ul><li>减少http请求，将小文件合并成成大文件。</li><li>使用http2。</li><li>使用服务端渲染。</li><li>静态资源使用cdn。</li><li>css文件放头部，js放尾部。</li><li>使用iconfont代替图片图标。</li><li>使用fontmin-webpack压缩字体文件。</li><li>使用gzip压缩文件。</li><li>使用data-src实现图片懒加载，data-src放真实图片路径，src放默认图片，当图片到可视区域把真实图片赋值给src。</li><li>媒体查询替换图片，webp,使用css代替图片。</li><li>减少重绘重排，比如用class不要频繁改样式。</li><li>使用事件委托。</li><li>vue打包优化：路由懒加载，通过注释指定webpackChunkName，自定义打包文件名。</li><li>分析打包的大小 npm run preview -- --report。</li><li>webpack配置排除打包，externals。</li><li>打包去除console.log</li><li>dns预查询<code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://fonts.googleapis.com/&quot;&gt;</code></li></ul>',21);a.render=function(c,r,a,l,o,n){return t(),e("div",null,[i])};export default a;export{r as __pageData};
