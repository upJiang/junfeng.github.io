import{g as e,f as o,E as t}from"./common-d6bd45c0.js";const n='{"title":"执行顺序","frontmatter":{},"headers":[{"level":2,"title":"执行顺序","slug":"执行顺序"},{"level":2,"title":"promise","slug":"promise"}],"relativePath":"docs/reStudy/js_eventLoop.md","lastUpdated":1639657876305.88}';var r={};const s=t('<p>event loop 分为宏任务跟微任务，是单线程</p><p>宏任务：就是由宿主（node,浏览器）主动发起的 script,settimeout,setInterval...</p><p>微任务：就是由javascript引擎发起，就是由代码产生的，也就是只有promise的then跟process.nexktick</p><p><a data-fancybox title="image.png" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3494484adf483ba9989586a0fd5459~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d3494484adf483ba9989586a0fd5459~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><h2 id="执行顺序"><a class="header-anchor" href="#执行顺序" aria-hidden="true">#</a> 执行顺序</h2><p>1.先执行script中的同步代码</p><p>2.同步代码执行完毕，执行异步代码中的微任务，微任务优先于宏任务，即then，nextick,promise这些要比settimeout这些先执行</p><p>3.执行异步中的所有微任务（不管顺序，只要不遇到宏任务）执行完毕后，在执行过程中，会把遇到的宏任务添加到‘宏任务栈’中</p><p>4.执行‘宏任务栈’，先添加的先执行，在里面还是先执行微任务，遇到宏任务又添加到‘宏任务栈’中，于此循环往复，直到全部执行完毕</p><blockquote><p>简单总结一句话就是：同步任务结束后，先处理微任务，然后处理宏任务，宏观任务内部处理重复上述动作。</p></blockquote><h4 id="微任务始终先于宏任务"><a class="header-anchor" href="#微任务始终先于宏任务" aria-hidden="true">#</a> 微任务始终先于宏任务</h4><div class="language-"><pre><code>setTimeout(()=&gt;{\n    console.log(&quot;c5&quot;)\n    setTimeout(()=&gt;{\n        console.log(&quot;c9&quot;)\n        new Promise(function(resolve, reject){\n           resolve()\n        }).then(() =&gt;{\n            console.log(&quot;c10&quot;)\n        })\n    }, 0)\n    new Promise(function(resolve, reject){\n           resolve()\n        }).then(() =&gt;{\n            console.log(&quot;c6&quot;)\n        })\n}, 0)\nvar r = new Promise(function(resolve, reject){\n    console.log(&quot;c1&quot;)\n    resolve()\n});\nr.then(() =&gt; { \n    var begin = Date.now();\n    while(Date.now() - begin &lt; 1000);\n    console.log(&quot;c2&quot;) \n    new Promise(function(resolve, reject){\n        resolve()\n    }).then(() =&gt;{\n        console.log(&quot;c3&quot;);\n        setTimeout(()=&gt; console.log(&quot;c7&quot;), 0)\n        new Promise(function(resolve, reject){\n           resolve()\n        }).then(() =&gt;{\n            console.log(&quot;c4&quot;)\n            setTimeout(()=&gt;{        \n                setTimeout(()=&gt;{\n                 console.log(&quot;c11&quot;)\n                }, 0)\n                 console.log(&quot;c8&quot;)\n            }, 0)\n        })\n    }) \n});\n\n执行顺序：c1 - c11\n</code></pre></div><h2 id="promise"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> promise</h2><blockquote><p>Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。</p></blockquote><p>基本用法：</p><div class="language-"><pre><code>function sleep(duration) {\n    return new Promise(function(resolve, reject) {\n        setTimeout(resolve,duration);\n    })\n}\nsleep(1000).then( ()=&gt; console.log(&quot;finished&quot;));\n</code></pre></div>',16);r.render=function(t,n,r,c,i,l){return o(),e("div",null,[s])};export default r;export{n as __pageData};
