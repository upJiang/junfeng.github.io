import{g as e,f as n,E as r}from"./common-d6bd45c0.js";const t='{"title":"promise 篇","frontmatter":{},"headers":[{"level":2,"title":"promise 篇","slug":"promise-篇"},{"level":3,"title":"实现 promise","slug":"实现-promise"},{"level":3,"title":"实现 promise.all","slug":"实现-promise-all"},{"level":3,"title":"实现 promise.finally","slug":"实现-promise-finally"},{"level":3,"title":"实现 promise.allSettled","slug":"实现-promise-allsettled"},{"level":3,"title":"实现 promise.any","slug":"实现-promise-any"},{"level":2,"title":"array 数组篇","slug":"array-数组篇"},{"level":3,"title":"实现数组去重","slug":"实现数组去重"},{"level":3,"title":"foreach","slug":"foreach"},{"level":3,"title":"reduce","slug":"reduce"},{"level":2,"title":"节流防抖","slug":"节流防抖"},{"level":2,"title":"深拷贝","slug":"深拷贝"},{"level":2,"title":"实现 new","slug":"实现-new"},{"level":2,"title":"Function 篇","slug":"function-篇"},{"level":3,"title":"Call","slug":"call"},{"level":3,"title":"Apply","slug":"apply"},{"level":3,"title":"Bind","slug":"bind"}],"relativePath":"docs/interview/writeQuestion.md","lastUpdated":1644324664910.0051}';var l={};const o=r('<h2 id="promise-篇"><a class="header-anchor" href="#promise-篇" aria-hidden="true">#</a> promise 篇</h2><h3 id="实现-promise"><a class="header-anchor" href="#实现-promise" aria-hidden="true">#</a> 实现 promise</h3><p>分析一下基本原理：</p><ol><li>Promise 是一个类，在执行这个类的时候会传入一个执行器，这个执行器会立即执行</li><li>Promise 会有三种状态 <ul><li>Pending 等待</li><li>Fulfilled 完成</li><li>Rejected 失败</li></ul></li><li>状态只能由 Pending --&gt; Fulfilled 或者 Pending --&gt; Rejected，且一但发生改变便不可二次修改；</li><li>Promise 中使用 resolve 和 reject 两个函数来更改状态；</li><li>then 方法内部做的事情就是状态判断 <ul><li>如果状态是成功，调用成功回调函数</li><li>如果状态是失败，调用失败回调函数</li></ul></li></ol><p>实现代码</p><div class="language-"><pre><code>// MyPromise.js\n\n// 先定义三个常量表示状态\nconst PENDING = &quot;pending&quot;;\nconst FULFILLED = &quot;fulfilled&quot;;\nconst REJECTED = &quot;rejected&quot;;\n\n\n// 新建 MyPromise 类\nclass MyPromise {\n    constructor(executor) {\n        // executor 是一个执行器，进入会立即执行\n        // 并传入resolve和reject方法\n        executor(this.resolve, this.reject);\n    }\n\n    // 储存状态的变量，初始值是 pending\n    status = PENDING;\n\n    // resolve和reject为什么要用箭头函数？\n    // 如果直接调用的话，普通函数this指向的是window或者undefined\n    // 用箭头函数就可以让this指向当前实例对象\n    // 成功之后的值\n    value = null;\n    // 失败之后的原因\n    reason = null;\n\n    // 存储成功回调函数\n    // onFulfilledCallback = null;\n    onFulfilledCallbacks = [];\n    // 存储失败回调函数\n    // onRejectedCallback = null;\n    onRejectedCallbacks = [];\n\n    // 更改成功后的状态\n    resolve = (value) =&gt; {\n        // 只有状态是等待，才执行状态修改\n        if (this.status === PENDING) {\n            // 状态修改为成功\n            this.status = FULFILLED;\n            // 保存成功之后的值\n            this.value = value;\n            // ==== 新增 ====\n            // resolve里面将所有成功的回调拿出来执行\n            while (this.onFulfilledCallbacks.length) {\n                // Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空\n                this.onFulfilledCallbacks.shift()(value);\n            }\n        }\n    };\n\n    // 更改失败后的状态\n    // 更改失败后的状态\n    reject = (reason) =&gt; {\n        // 只有状态是等待，才执行状态修改\n        if (this.status === PENDING) {\n            // 状态成功为失败\n            this.status = REJECTED;\n            // 保存失败后的原因\n            this.reason = reason;\n            // ==== 新增 ====\n            // resolve里面将所有失败的回调拿出来执行\n            while (this.onRejectedCallbacks.length) {\n                this.onRejectedCallbacks.shift()(reason)\n            }\n        }\n    }\n\n\n    then(onFulfilled, onRejected) {\n        // 判断状态\n        if (this.status === FULFILLED) {\n            // 调用成功回调，并且把值返回\n            onFulfilled(this.value);\n        } else if (this.status === REJECTED) {\n            // 调用失败回调，并且把原因返回\n            onRejected(this.reason);\n        } else if (this.status === PENDING) {\n            // ==== 新增 ====\n            // 因为不知道后面状态的变化，这里先将成功回调和失败回调存储起来\n            // 等待后续调用\n            this.onFulfilledCallbacks.push(onFulfilled);\n            this.onRejectedCallbacks.push(onRejected);\n        }\n    }\n}\n\nmodule.exports = MyPromise;\n</code></pre></div><p>实现结果</p><div class="language-"><pre><code>const MyPromise = require(&#39;./MyPromise&#39;)\nconst promise = new MyPromise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n        resolve(&#39;success&#39;)\n    }, 2000);\n})\n\npromise.then(value =&gt; {\n    console.log(1)\n    console.log(&#39;resolve&#39;, value)\n})\n\npromise.then(value =&gt; {\n    console.log(2)\n    console.log(&#39;resolve&#39;, value)\n})\n\npromise.then(value =&gt; {\n    console.log(3)\n    console.log(&#39;resolve&#39;, value)\n})\n\n// 1\n// resolve success\n// 2\n// resolve success\n// 3\n// resolve success\n</code></pre></div><h3 id="实现-promise-all"><a class="header-anchor" href="#实现-promise-all" aria-hidden="true">#</a> 实现 promise.all</h3><p>思路：</p><ol><li>判断传入的是数组类型</li><li>定义数组保存每一个 promise 的返回结果，同时开始计数，当数量等于传入的数组长度，则执行完成</li><li>如果遇到 reject，直接返回 reject 的失败原因，如果全部成功，则返回结果数组</li></ol><p>实现方法</p><div class="language-"><pre><code>function PromiseAll(promises) {\n    return new Promise((resolve, reject) =&gt; {\n        // 判断传入的必须是数组\n        if (!Array.isArray(promises)) {\n            throw new TypeError(&quot;promises must be an array&quot;)\n        }\n        let result = [] // 保存结果\n        let count = 0  // 用于判断是否全部执行完\n        promises.forEach((promise, index) =&gt; {\n            promise.then((res) =&gt; {\n                console.log(&quot;res&quot;, res);\n                result[index] = res\n                count++\n                count === promises.length &amp;&amp; resolve(result)  //全部执行完后输出结果\n            }, (err) =&gt; {\n                reject(err)\n            })\n        })\n    })\n}\n\nmodule.exports = PromiseAll;\n</code></pre></div><p>实现结果</p><div class="language-"><pre><code>const PromiseAll = require(&#39;./promiseAll&#39;)\n\nconst promise1 = new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n        resolve(&#39;success1&#39;)\n    }, 5000);\n})\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n        resolve(&#39;success2&#39;)\n    }, 1000);\n})\n\nconst promise3 = new Promise((resolve, reject) =&gt; {\n    reject(&#39;error&#39;)\n})\n\nPromiseAll([promise1, promise2, promise3]).then((res) =&gt; {\n    console.log(&quot;全部执行完成&quot;, res);\n}).catch((error) =&gt; {\n    console.log(&quot;执行异常&quot;, error)\n})\n\n//执行结果，如果没有 reject，输出 [&#39;success1&#39;,&#39;success1&#39;]，reject 输出 error\n</code></pre></div><h3 id="实现-promise-finally"><a class="header-anchor" href="#实现-promise-finally" aria-hidden="true">#</a> 实现 promise.finally</h3><p>实现代码</p><div class="language-"><pre><code>// 由于无法知道promise的最终状态，所以finally的回调函数中不接收任何参数，\n// 它仅用于无论最终结果如何都要执行的情况\n// 并且finally之后，还可以继续then。并且会将值原封不动的传递给后面的then\n\nPromise.prototype.myFinally = function (cb) {\n    // 此处的 this 是一个 pending状态的 promise，resolve(cb())会执行 finally 的代码\n    // promise后有可能还是一个promise，finally需要原封不动的返回 return结果\n    return this.then((value) =&gt; {\n        return Promise.resolve(cb()).then(function () {\n            return value\n        })\n    }, (err) =&gt; {\n        return Promise.resolve(cb()).then(function () {\n            throw err\n        })\n    })\n}\n\nconst promise = new Promise((resolve, reject) =&gt; {\n    resolve(&#39;success&#39;)\n})\n\npromise.then((res) =&gt; {\n    return new Promise((resolve) =&gt; {\n        resolve(&#39;success1&#39;)\n    })\n}).myFinally(() =&gt; {\n    console.log(&quot;执行finally&quot;);\n}).then((res) =&gt; {\n    console.log(&quot;finally后，原封不动返回值&quot;, res);\n})\n\n// 输出：执行finally finally后，原封不动返回值 success1\n</code></pre></div><h3 id="实现-promise-allsettled"><a class="header-anchor" href="#实现-promise-allsettled" aria-hidden="true">#</a> 实现 promise.allSettled</h3><p>实现代码</p><div class="language-"><pre><code>function allSettled(promises) {\n    if (promises.length === 0) return Promise.resolve([])\n\n    const _promises = promises.map(\n        item =&gt; item instanceof Promise ? item : Promise.resolve(item)\n    )\n    return new Promise((resolve, reject) =&gt; {\n        const result = []\n        let unSettledPromiseCount = _promises.length\n\n        _promises.forEach((promise, index) =&gt; {\n            promise.then((value) =&gt; {\n                result[index] = {\n                    status: &#39;fulfilled&#39;,\n                    value\n                }\n\n                unSettledPromiseCount -= 1\n                // resolve after all are settled\n                if (unSettledPromiseCount === 0) {\n                    resolve(result)\n                }\n            }, (reason) =&gt; {\n                result[index] = {\n                    status: &#39;rejected&#39;,\n                    reason\n                }\n\n                unSettledPromiseCount -= 1\n                // resolve after all are settled\n                if (unSettledPromiseCount === 0) {\n                    resolve(result)\n                }\n            })\n        })\n\n    })\n}\n\nmodule.exports = allSettled;\n\n// 思路：\n// 当所有的 promise 都执行完了把结果组成数组，包含状态以及 value。\n// 首先判断传入的 promise 数组长度，为0直接返回空数组\n// 如果 promise 中没有 reslove 或 reject 的，我们只处理 reslove 或 reject 的，所以没有会直接跳出不执行，停止\n// 通过计数 -1 ，以及包装结果，返回全部正常结束的最终结果\n</code></pre></div><p>实现结果</p><div class="language-"><pre><code>const promiseAllSettled = require(&#39;./promiseAllSettled&#39;)\n\nconst promise1 = new Promise((resolve, reject) =&gt; {\n    resolve(&#39;success1&#39;)\n})\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n    // resolve(&#39;success2&#39;)\n    console.log(&quot;sdf&quot;);\n})\n\nconst promise3 = new Promise((resolve, reject) =&gt; {\n    reject(&#39;error&#39;)\n\n})\n\npromiseAllSettled([promise1, promise2, promise3]).then((res) =&gt; {\n    console.log(&quot;AllSettled全部执行完成&quot;, res);\n})\n\n// 执行结果\n//  全部执行完成 [\n//     { status: &#39;fulfilled&#39;, value: &#39;success1&#39; },\n//     { status: &#39;fulfilled&#39;, value: &#39;success2&#39; },\n//     { status: &#39;rejected&#39;, reason: &#39;error&#39; }\n//   ]\n</code></pre></div><h3 id="实现-promise-any"><a class="header-anchor" href="#实现-promise-any" aria-hidden="true">#</a> 实现 promise.any</h3><p>实现方法</p><div class="language-"><pre><code>function promiseAny(promiseArr) {\n    let index = 0\n    return new Promise((resolve, reject) =&gt; {\n        if (promiseArr.length === 0) return\n        promiseArr.forEach((p, i) =&gt; {\n            Promise.resolve(p).then(val =&gt; {\n                resolve(val)\n\n            }, err =&gt; {\n                index++\n                if (index === promiseArr.length) {\n                    reject(new AggregateError(&#39;All promises were rejected&#39;))\n                }\n            })\n        })\n    })\n}\n\nmodule.exports = promiseAny;\n\n// 思路：\n// 计数，当遇到成功状态，就返回这个结果，当全部都失败，就返回失败信息\n</code></pre></div><p>实现结果</p><div class="language-"><pre><code>// 执行 promise 数组，当遇到一个 成功状态，就返回这个成功结果，如果全部失败，就返回 失败提示// 执行所有的 promise，返回所有的 promise 状态与结果，reject不影响过程\n\nconst promiseAny = require(&#39;./promiseAny&#39;)\n\nconst promise1 = new Promise((resolve, reject) =&gt; {\n    resolve(&#39;success1&#39;)\n})\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n    resolve(&#39;success2&#39;)\n})\n\nconst promise3 = new Promise((resolve, reject) =&gt; {\n    reject(&#39;error&#39;)\n})\n\npromiseAny([promise1, promise2, promise3]).then((res) =&gt; {\n    console.log(&quot;promiseAny结果&quot;, res);\n})\n\n// 执行结果\n// promiseAny结果 success1\n</code></pre></div><h2 id="array-数组篇"><a class="header-anchor" href="#array-数组篇" aria-hidden="true">#</a> array 数组篇</h2><h3 id="实现数组去重"><a class="header-anchor" href="#实现数组去重" aria-hidden="true">#</a> 实现数组去重</h3><div class="language-"><pre><code>//ES6 提供的 Set 去重\nfunction unique(arr) {\n    const result = new Set(arr);\n    return [...result];\n    // return Array.from(result); //不兼容ie\n    //使用扩展运算符将Set数据结构转为数组\n}\n\n// filter 配合 indexOf，\n//使用 indexOf 获取当前内容的下标，这个下标必须跟当前 index 相等，不想等说明出现在别的地方，是重复的需过滤\nfunction unique(arr) {\n    return arr.filter(function (item, index, arr) {\n        return arr.indexOf(item) === index;\n    })\n}\n\n// reduce\nlet arr = [1, 2, 2, 4, null, null].reduce((accumulator, current) =&gt; {\n    return accumulator.includes(current) ? accumulator : accumulator.concat(current);\n}, []);\n</code></pre></div><h3 id="foreach"><a class="header-anchor" href="#foreach" aria-hidden="true">#</a> foreach</h3><div class="language-"><pre><code>Array.prototype.myForEach = function (callbackFn) {\n    // 判断this是否合法\n    if (this === null || this === undefined) {\n        throw new TypeError(&quot;Cannot read property &#39;myForEach&#39; of null&quot;);\n    }\n    // 判断callbackFn是否合法\n    if (Object.prototype.toString.call(callbackFn) !== &quot;[object Function]&quot;) {\n        throw new TypeError(callbackFn + &#39; is not a function&#39;)\n    }\n    // 取到执行方法的数组对象和传入的this对象\n    var _arr = this, thisArg = arguments[1] || window;\n    for (var i = 0; i &lt; _arr.length; i++) {\n        // 执行回调函数\n        callbackFn.call(thisArg, _arr[i], i, _arr);\n    }\n}\n</code></pre></div><h3 id="reduce"><a class="header-anchor" href="#reduce" aria-hidden="true">#</a> reduce</h3><p>先理解 reduce 的用法：</p><div class="language-"><pre><code>array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)\n</code></pre></div><p>接受四个参数：</p><ul><li>accumulator 累加器，当前执行的结果</li><li>currentValue 当前执行的值</li><li>currentIndex 当前执行的index</li><li>array 正在被执行的数组</li><li>initialValue 初始值</li></ul><p>必须要 retuen，这样后续才能获取之前的值，继续进行操作</p><p>看例子：</p><div class="language-"><pre><code>// 计数\n// 无初始值\nlet total = [1, 2, 3, 4].reduce((accumulator, current) =&gt; accumulator += current); // 10\n\n// 有初始值\nlet total = [1, 2, 3, 4].reduce((accumulator, current) =&gt; accumulator += current, 90); // 100\n\n// 数组去重\nlet arr = [1, 2, 2, 4, null, null].reduce((accumulator, current) =&gt; {\n    return accumulator.includes(current) ? accumulator : accumulator.concat(current);\n}, []);\n</code></pre></div><p>实现代码</p><div class="language-"><pre><code>Array.prototype.myReduce = function (callbackFn) {\n    var _arr = this, accumulator = arguments[1];\n    var i = 0;\n    // 判断是否传入初始值\n    if (accumulator === undefined) {\n        // 没有初始值的空数组调用reduce会报错\n        if (_arr.length === 0) {\n            throw new Error(&#39;initVal and Array.length&gt;0 need one&#39;)\n        }\n        // 初始值赋值为数组第一个元素\n        accumulator = _arr[i];\n        i++;\n    }\n    for (; i &lt; _arr.length; i++) {\n        // 计算结果赋值给初始值\n        accumulator = callbackFn(accumulator, _arr[i], i, _arr)\n    }\n    return accumulator;\n}\n\n// 思路：\n// 判断是否传入初始值，如果没有传入初始值并且，第一个数组还是空的，就返回异常，否则将数组的第一项作为初始值\n// 开始循环数组，迭代执行传入的方法，传入四个值\n// 接受四个参数：\n// - accumulator 累加器，当前执行的结果\n// - currentValue 当前执行的值\n// - currentIndex 当前执行的index\n// - array 正在被执行的数组\n// - initialValue 初始值\n</code></pre></div><h2 id="节流防抖"><a class="header-anchor" href="#节流防抖" aria-hidden="true">#</a> 节流防抖</h2><p>节流： 多次触发同一个函数，同一段时间内只执行一次，所以节流会稀释函数的执行频率</p><blockquote><p>可以看出节流的主要原理就是利用时间差（当前和上次执行）来过滤中间过程触发的函数执行。控制是否在开始时会立即触发一次，及最后一次触发是否执行,添加取消的功能</p></blockquote><div class="language-"><pre><code>// 节流： 多次触发同一个函数，同一段时间内只执行一次，所以节流会稀释函数的执行频率。触发后只在乎时间，时间到了才执行\n// 如果事件不停的触发，它会在规定的时间内一直触发\n\n// fn：执行的方法，wait：等待的时间，immediate：第一次进入是否执行\n\n// 设置上次执行毫秒数初始值 0 ，设置 当前毫秒数 now，通过 now - previous 是否大于传入的等待毫秒数控制方法执行\n\n// 每次点击进入\nfunction throttle(fn, wait, immediate = false) {\n    let timer; // 定时器\n    let previous = 0; // 上次执行毫秒数初始化 0\n\n    const throttled = function (...args) {\n        // args 为执行函数传入的参数\n\n        // 清除上一个 timer\n        if (timer) clearTimeout(timer);\n\n        const now = +new Date();\n        // 如果第一次进来：previous === 0 并且不需要立即执行 immediate === false\n        // 设置当当前毫秒数等于上次执行毫秒数，相减等于0，肯定小于等待时间 wait，所以不能立即执行。\n        if (immediate === false &amp;&amp; !previous) previous = now; // 控制不能立即执行\n\n        // now - previous 是否大于传入的等待毫秒数控制方法执行\n        if (now - previous &gt; wait) {\n            fn.apply(this, args);\n            previous = now; // 执行完将上次执行毫秒数设置为当前毫秒数\n        }\n    }\n\n    // 提供马上停止的方法\n    throttled.cancel = () =&gt; {\n        clearTimeout(timer);\n        timer = null;\n        previous = 0;\n    }\n\n    return throttled;\n}\n</code></pre></div><p>防抖： 按最后一次算。比如说“停止输入5s后才发送请求”，防止多次点击 (比较常用)</p><blockquote><p>可以看出debounce函数的实现原理就是通过计时器延迟函数执行，短时间内再次触发时重置并添加新计时器。</p></blockquote><div class="language-"><pre><code>// 防抖： 按最后一次算。比如说“停止输入5s后才发送请求”，防止多次点击  (比较常用)\n// 你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行\n// 总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行。\n\n// 关键点就是，进来清除上一次的定时器，重新设置定时器\n\n// 可以看出debounce函数的实现原理就是通过计时器延迟函数执行，短时间内再次触发时重置并添加新计时器。\n\n//第一次触发可以立即执行，并且有取消功能\nfunction debounce(fn, wait = 1000, immediate = false) {\n    let timer = null;\n\n    function debounced(...args) {\n        // 每次进来都重置计时器，当没有触发了，才真正执行，\n        // 或者是 延迟时间 比 触发间隔短 执行\n        timer &amp;&amp; clearTimeout(timer);\n\n        // 首次立即执行\n        if (immediate &amp;&amp; !timer) {\n            fn.apply(this, ...args);\n            // 立即执行完，再过 wait 就不执行了\n            timer = setTimeout(() =&gt; {\n                timer = null;\n            }, wait);\n            return;\n        }\n\n        // 新计时器\n        timer = setTimeout(() =&gt; {\n            fn.apply(this, ...args);\n            timer = null;\n        }, wait);\n    }\n\n    debounced.cancel = () =&gt; {\n        clearTimeout(timer);\n        timer = null;\n    };\n\n    return debounced;\n}\n</code></pre></div><h2 id="深拷贝"><a class="header-anchor" href="#深拷贝" aria-hidden="true">#</a> 深拷贝</h2><p>深拷贝，只拷贝内容，不拷贝地址，不会造成互相影响</p><div class="language-"><pre><code>const deepClone = (target) =&gt; {\n    // 判断是否是对象并且不为null\n    if (typeof target === &#39;object&#39; &amp;&amp; target !== null) {\n        const cloneTarget = Array.isArray(target) ? [] : {};\n        // 递归克隆\n        for (let prop in target) {\n            if (target.hasOwnProperty(prop)) {\n                cloneTarget[prop] = deepClone(target[prop]);\n            }\n        }\n        return cloneTarget;\n    } else {\n        return target;\n    }\n}\n\nconst object1 = {\n    a: 1,\n    b: {\n        c: 2\n    },\n    d: [&#39;1&#39;, &#39;2&#39;]\n}\n\nconst object2 = deepClone(object1) // 这里两个的a为1 和 3\n// const object2 = object1 // 这里两个的a都将输出3\n\nobject2.a = 3\nconsole.log(&#39;object1&#39;, object1);\nconsole.log(&#39;object2&#39;, object2);\n</code></pre></div><h2 id="实现-new"><a class="header-anchor" href="#实现-new" aria-hidden="true">#</a> 实现 new</h2><div class="language-"><pre><code>function createObject(Con) {\n    // 创建新对象obj\n    // var obj = {};也可以\n    var obj = Object.create(null);\n\n    // 将obj.__proto__ -&gt; 构造函数原型\n    // (不推荐)obj.__proto__ = Con.prototype\n    Object.setPrototypeOf(obj, Con.prototype);\n\n    // 执行构造函数，并接受构造函数返回值\n    const ret = Con.apply(obj, [].slice.call(arguments, 1));\n\n    // 若构造函数返回值为对象，直接返回该对象\n    // 否则返回obj\n    return typeof(ret) === &#39;object&#39; ? ret: obj;\n}\n</code></pre></div><h2 id="function-篇"><a class="header-anchor" href="#function-篇" aria-hidden="true">#</a> Function 篇</h2><h3 id="call"><a class="header-anchor" href="#call" aria-hidden="true">#</a> Call</h3><div class="language-"><pre><code>Function.prototype.myCall = function (thisArg) {\n    thisArg = thisArg || window;\n    thisArg.func = this;\n    const args = []\n    for (let i = 1; i&lt;arguments.length; i++) {\n        args.push(&#39;arguments[&#39;+ i + &#39;]&#39;)\n    }\n    const result = eval(&#39;thisArg.func(&#39; + args +&#39;)&#39;)\n    delete thisArg.func;\n    return result;\n}\n</code></pre></div><h3 id="apply"><a class="header-anchor" href="#apply" aria-hidden="true">#</a> Apply</h3><div class="language-"><pre><code>Function.prototype.myApply = function (thisArg, arr) {\n    thisArg = thisArg || window;\n    thisArg.func = this;\n    const args = []\n    for (let i = 0; i&lt;arr.length; i++) {\n        args.push(&#39;arr[&#39;+ i + &#39;]&#39;)\n    }\n    const result = eval(&#39;thisArg.func(&#39; + args +&#39;)&#39;)\n    delete thisArg.func;\n    return result;\n}\n</code></pre></div><h3 id="bind"><a class="header-anchor" href="#bind" aria-hidden="true">#</a> Bind</h3><div class="language-"><pre><code>Function.prototype.sx_bind = function (obj, ...args) {\n    obj = obj || window\n\n    const fn = Symbol()\n    obj[fn] = this\n    const _this = this\n\n    const res = function (...innerArgs) {\n        console.log(this, _this)\n        if (this instanceof _this) {\n            this[fn] = _this\n            this[fn](...[...args, ...innerArgs])\n            delete this[fn]\n        } else {\n            obj[fn](...[...args, ...innerArgs])\n            delete obj[fn]\n        }\n    }\n    res.prototype = Object.create(this.prototype)\n    return res\n}\n</code></pre></div>',62);l.render=function(r,t,l,s,i,a){return n(),e("div",null,[o])};export default l;export{t as __pageData};
