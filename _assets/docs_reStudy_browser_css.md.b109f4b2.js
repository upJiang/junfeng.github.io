import{g as l,f as a,E as p}from"./common-d6bd45c0.js";const e='{"title":"整体过程","frontmatter":{},"headers":[{"level":2,"title":"整体过程","slug":"整体过程"},{"level":2,"title":"后代选择器 “空格”","slug":"后代选择器-“空格”"},{"level":2,"title":"后继选择器“ ~ ”","slug":"后继选择器“-”"},{"level":2,"title":"子代选择器“ >”","slug":"子代选择器“-”"},{"level":2,"title":"直接后继选择器“ +”","slug":"直接后继选择器“-”"},{"level":2,"title":"列选择器“ || ”","slug":"列选择器“-”"},{"level":2,"title":"其它","slug":"其它"},{"level":2,"title":"总结","slug":"总结"}],"relativePath":"docs/reStudy/browser_css.md","lastUpdated":1640001089950.6692}';var n={};const s=p('<p><strong>浏览器是如何把 CSS 规则应用到节点上，并给这棵朴素的 DOM 树添加上 CSS 属性的?</strong></p><h2 id="整体过程"><a class="header-anchor" href="#整体过程" aria-hidden="true">#</a> 整体过程</h2><p>首先 CSS 选择器这个名称，可能会给你带来一定的误解，觉得好像 CSS 规则是 DOM 树构建好了以后，再进行选择并给它添加样式的。实际上，这个过程并不是这样的。</p><p>我们回忆一下我们在浏览器第一节课讲的内容，浏览器会尽量流式处理整个过程。我们上一节课构建 DOM 的过程是：从父到子，从先到后，一个一个节点构造，并且挂载到 DOM 树上的，那么这个过程中，我们是否能同步把 CSS 属性计算出来呢？答案是肯定的。</p><p>在这个过程中，我们依次拿到上一步构造好的元素，去检查它匹配到了哪些规则，再根据规则的优先级，做覆盖和调整。所以，从这个角度看，所谓的选择器，应该被理解成“匹配器”才更合适。</p><p>我在 CSS 语法部分，已经总结了选择器的各种符号，这里再把它列出来，我们回顾一下。</p><ul><li>空格: 后代，选中它的子节点和所有子节点的后代节点。</li><li><blockquote><p>: 子代，选中它的子节点。</p></blockquote></li><li>+：直接后继选择器，选中它的下一个相邻节点。</li><li>~：后继，选中它之后所有的相邻节点。</li><li>||：列，选中表格中的一列。</li></ul><p>不知道你有没有发现，这里的选择器有个特点，那就是选择器的出现顺序，必定跟构建 DOM 树的顺序一致。这是一个 CSS 设计的原则，即保证选择器在 DOM 树构建到当前节点时，已经可以准确判断是否匹配，不需要后续节点信息。</p><p>也就是说，未来也不可能会出现“父元素选择器”这种东西，因为父元素选择器要求根据当前节点的子节点，来判断当前节点是否被选中，而父节点会先于子节点构建。</p><p>理解了 CSS 构建的大概过程，我们下面来看看具体的操作。</p><p>首先，我们必须把 CSS 规则做一下处理。作为一门语言，CSS 需要先经过词法分析和语法分析，变成计算机能够理解的结构。</p><p>这部分具体的做法属于编译原理的内容，这里就不做赘述了。我们这里假设 CSS 已经被解析成了一棵可用的抽象语法树。</p><p>我们在之前的 CSS 课程中已经介绍过 compound-selector 的概念，一个 compound-selector 是检查一个元素的规则，而一个复合型选择器，则是由数个 compound-selector 通过前面讲的符号连接起来的。</p><h2 id="后代选择器-“空格”"><a class="header-anchor" href="#后代选择器-“空格”" aria-hidden="true">#</a> 后代选择器 “空格”</h2><p>我们先来分析一下后代选择器，我们来一起看一个例子：</p><div class="language-"><pre><code>a#b .cls {\n    width: 100px;\n}\n</code></pre></div><p>可以把一个 CSS 选择器按照 compound-selector 来拆成数段，每当满足一段条件的时候，就前进一段。</p><p>比如，在上面的例子中，当我们找到了匹配 a#b 的元素时，我们才会开始检查它所有的子代是否匹配 .cls。</p><p>除了前进一段的情况，我们还需要处理后退的情况，比如，我们这样一段代码：</p><div class="language-"><pre><code>&lt;a id=b&gt;\n    &lt;span&gt;1&lt;span&gt;\n    &lt;span class=cls&gt;2&lt;span&gt;\n&lt;/a&gt;\n&lt;span class=cls&gt;3&lt;span&gt;\n</code></pre></div><p>当遇到 时，必须使得规则 a#b .cls 回退一步，这样第三个 span 才不会被选中。后代选择器的作用范围是父节点的所有子节点，因此规则是在匹配到本标签的结束标签时回退。</p><h2 id="后继选择器“-”"><a class="header-anchor" href="#后继选择器“-”" aria-hidden="true">#</a> 后继选择器“ ~ ”</h2><p>接下来我们看下后继选择器，跟后代选择器不同的地方是，后继选择器只作用于一层，我们来看一个例子：</p><div class="language-"><pre><code>.cls~* {\n    border:solid 1px green;\n}\n&lt;div&gt;\n&lt;span&gt;1&lt;span&gt;\n&lt;span class=cls&gt;2&lt;span&gt;\n&lt;span&gt;\n    3\n    &lt;span&gt;4&lt;/span&gt;\n&lt;span&gt;\n&lt;span&gt;5&lt;/span&gt;\n&lt;/div&gt;\n</code></pre></div><p>这里 .cls 选中了 span 2 然后 span 3 是它的后继，但是 span 3 的子节点 span 4 并不应该被选中，而 span 5 也是它的后继，因此应该被选中。</p><p>按照 DOM 树的构造顺序，4 在 3 和 5 中间，我们就没有办法像前面讲的后代选择器一样通过激活或者关闭规则来实现匹配。</p><p>但是这里有个非常方便的思路，就是给选择器的激活，带上一个条件：父元素。</p><p>意，这里后继选择器，当前半段的 .cls 匹配成功时，后续 * 所匹配的所有元素的父元素都已经确定了（后继节点和当前节点父元素相同是充分必要条件）。在我们的例子中，那个 div 就是后继节点的父元素。</p><h2 id="子代选择器“-”"><a class="header-anchor" href="#子代选择器“-”" aria-hidden="true">#</a> 子代选择器“ &gt;”</h2><p>实际上，有了前面讲的父元素这个约束思路，我们很容易实现子代选择器。区别仅仅是拿当前节点作为父元素，还是拿当前节点的父元素作为父元素。</p><div class="language-"><pre><code>div&gt;.cls {\n    border:solid 1px green;\n}\n&lt;div&gt;\n&lt;span&gt;1&lt;span&gt;\n&lt;span class=cls&gt;2&lt;span&gt;\n&lt;span&gt;\n    3\n    &lt;span&gt;4&lt;/span&gt;\n&lt;span&gt;\n&lt;span&gt;5&lt;/span&gt;\n&lt;/div&gt;\n</code></pre></div><p>我们看这段代码，当 DOM 树构造到 div 时，匹配了 CSS 规则的第一段，因为是子代选择器，我们激活后面的 .cls 选择条件，并且指定父元素必须是当前 div。于是后续的构建 DOM 树构建过程中，span 2 就被选中了。</p><h2 id="直接后继选择器“-”"><a class="header-anchor" href="#直接后继选择器“-”" aria-hidden="true">#</a> 直接后继选择器“ +”</h2><p>直接后继选择器的实现是上述中最为简单的了，因为它只对唯一一个元素生效，所以不需要像前面几种一样反复激活和关闭规则。</p><p>一个最简单的思路是，我们可以把它当作检查元素自身的选择器来处理。即我们把 #id+.cls 都当做检查某一个元素的选择器。</p><p>外的一种思路是：给后继选择器加上一个 flag，使它匹配一次后失效。</p><h2 id="列选择器“-”"><a class="header-anchor" href="#列选择器“-”" aria-hidden="true">#</a> 列选择器“ || ”</h2><p>列选择器比较特别，它是专门针对表格的选择器，跟表格的模型建立相关，我们这里不详细讲了。</p><h2 id="其它"><a class="header-anchor" href="#其它" aria-hidden="true">#</a> 其它</h2><p>我们不要忘记，CSS 选择器还支持逗号分隔，表示“或”的关系。这里最简单的实现是把逗号视为两条规则的一种简易写法。 比如：</p><div class="language-"><pre><code>a#b, .cls {\n\n}\n</code></pre></div><p>我们当作两条规则来处理：</p><div class="language-"><pre><code>a#b {\n\n}\n\n\n.cls {\n\n}\n</code></pre></div><p>还有一个情况，就是选择器可能有重合，这样，我们可以使用树形结构来进行一些合并，来提高效率：</p><div class="language-"><pre><code>#a .cls {\n\n}\n\n#a span {\n\n}\n#a&gt;span {\n\n}\n</code></pre></div><p>这里实际上可以把选择器构造成一棵树：</p><ul><li>#a <ul><li>&lt; 空格 &gt;.cls</li><li>&lt; 空格 &gt;span</li><li><code>&gt;span</code></li></ul></li></ul><p>需要注意的是，这里的树，必须要带上连接符。</p><h2 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>css的渲染过程：</p><ol><li><p>流式渲染，每生成一个dom节点，便立刻去匹配相应的css规则</p></li><li><p>dom节点的生成顺序是 从父-&gt; 子。 css的渲染顺序也是 从 父节点-》子节点</p></li><li><p>混合选择器 在激活的时候父元素已经确定好了 。 后代选择器，所有元素都是父元素，并 选中自己的子元素。 子元素 选择器，只有父元素为当前节点的 dom 元素会被选中。 在父元素 结束标签时，关闭 选择器。</p></li></ol>',51);n.render=function(p,e,n,t,d,i){return a(),l("div",null,[s])};export default n;export{e as __pageData};
