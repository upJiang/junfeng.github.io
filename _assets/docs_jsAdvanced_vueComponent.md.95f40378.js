import{g as t,f as e,E as n}from"./common-d6bd45c0.js";const o='{"title":"导入式组件","frontmatter":{},"headers":[{"level":2,"title":"导入式组件","slug":"导入式组件"},{"level":2,"title":"全局组件","slug":"全局组件"},{"level":2,"title":"函数式组件","slug":"函数式组件"}],"relativePath":"docs/jsAdvanced/vueComponent.md","lastUpdated":1639657876225.9233}';var p={};const a=n('<p>在我看来，vue3的开发中应该有三种组件封装形式，分别是<br></p><ol><li>最普通的导入式组件<br></li><li>全局组件（就类似于组件库antd的全局导入）<br></li><li>函数式组件（也就是能够在js代码中使用的组件，类似于this.$message({})）<br></li></ol><p>现在我来分别介绍这三种组件该如何封装</p><p>组件目录结构<br><a data-fancybox title="image.png" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/110a543422174c5b872ec95c63e31b6b~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/110a543422174c5b872ec95c63e31b6b~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><h2 id="导入式组件"><a class="header-anchor" href="#导入式组件" aria-hidden="true">#</a> 导入式组件</h2><p>组件代码：/src/components/import/BButton.vue</p><div class="language-"><pre><code>&lt;template&gt;\n  &lt;a-button @click=&quot;clickBack&quot; type=&quot;primary&quot; plain&gt; {{ text }} &lt;/a-button&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { useRouter } from &quot;vue-router&quot;;\nconst props = defineProps({\n  text: { type: String, default: &quot;返回&quot; },\n  backLevel: {\n    type: Number,\n    default: 1,\n  },\n});\n\nconst router = useRouter();\nconst clickBack = () =&gt; {\n  router.go(-props.backLevel);\n};\n&lt;/script&gt;\n</code></pre></div><p>在页面导入使用：/src/views/Home.vue</p><div class="language-"><pre><code>import BButton from &#39;@/components/import/BButton.vue&#39;\n&lt;b-button text=&quot;最简单的导入组件&quot;&gt;&lt;/b-button&gt;\n</code></pre></div><h2 id="全局组件"><a class="header-anchor" href="#全局组件" aria-hidden="true">#</a> 全局组件</h2><p>组件代码：/src/components/common/BackButton.vue</p><div class="language-"><pre><code>&lt;template&gt;\n  &lt;a-button @click=&quot;clickBack&quot; type=&quot;primary&quot; plain&gt; {{text}} &lt;/a-button&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { useRouter } from &quot;vue-router&quot;;\nconst props = defineProps({\n  text: { type: String, default: &quot;返回&quot; },\n  backLevel: {\n    type: Number,\n    default: 1,\n  },\n});\n\nconst router = useRouter();\nconst clickBack = () =&gt; {\n  router.go(-props.backLevel);\n};\n&lt;/script&gt;\n</code></pre></div><p>全局导入：/src//config/d.ts</p><div class="language-"><pre><code>//通过vite提供的import.meta.globEager读取common目录下的所有vue组件，并且以 D+文件名 作为组件名。\n//在使用时使用 d-组件名的形式\nconst componentList = import.meta.globEager(&#39;../components/common/**&#39;);\nlet componentArray = new Object()\nObject.keys(componentList).forEach((key) =&gt; {\n    let keyArray = key.split(&#39;/&#39;)\n    let name = &#39;D&#39; + keyArray[keyArray.length - 1].split(&#39;.&#39;)[0]\n    componentArray[name] = componentList[key].default\n})\n\nexport default function (app) {\n    Object.keys(componentArray).forEach((key) =&gt; {\n        app.component(key, componentArray[key])\n    })\n}\n</code></pre></div><p>在main.ts中的use这个d.ts</p><div class="language-"><pre><code>import d from &quot;@/config/d&quot;;\napp.use(d)\n</code></pre></div><p>在页面中直接使用，不需要导入：/src/views/Home.vue</p><div class="language-"><pre><code>&lt;d-back-button text=&quot;这是全局导入的自定义组件，不需要在页面中单独导入&quot;&gt;&lt;/d-back-button&gt;\n</code></pre></div><h2 id="函数式组件"><a class="header-anchor" href="#函数式组件" aria-hidden="true">#</a> 函数式组件</h2><blockquote><p>这里我将会介绍如何在vue文件中使用，以及在ts/js文件中使用。<br> 我们可能会遇到一个场景，比如说需要在接口报错或者成功时弹出一个全局自定义的组件，要求不能在vue文件中去写，也不能使用组件库的组件，而是需要在axios这种js/ts文件中去写，这样才能做到通用。那么我们该如何在js中使用并封装一个函数式组件？</p></blockquote><p>组件代码：/src/components/function/components/tipsDialog.vue</p><div class="language-"><pre><code>&lt;template&gt;\n  &lt;Modal\n    v-model:visible=&quot;pageVisible&quot;\n    title=&quot;自定义全局函数组件&quot;\n    @ok=&quot;_sure&quot;\n    @cancel=&quot;pageVisible = false&quot;\n    :okText=&quot;okText&quot;\n  &gt;\n    {{content}}\n  &lt;/Modal&gt;\n&lt;/template&gt;\n\n&lt;script setup&gt;\nimport { ref, watch } from &quot;vue&quot;;\n//自定义函数组件无法使用全局组件，需要单独引入\nimport { Modal } from &quot;ant-design-vue&quot;;\nconst props = defineProps({\n  visible: {\n    type: Boolean,\n    default: false,\n  },\n  okText: {\n    type: String,\n    default: &quot;确定&quot;,\n  },\n  handleOk: {\n    type: Function, //成功回调\n    default: null,\n  },\n  remove: {\n    type: Function, //传入移除节点方法,这里是createApp中的方法\n    default: null,\n  },\n  content:{\n    type: String,\n    default: &quot;自定义全局函数组件......&quot;,\n  }\n});\n\nconst pageVisible = ref(false);\npageVisible.value = props.visible;\n// 监听显示的消失，需要移除dom\nwatch(\n  () =&gt; pageVisible.value,\n  (val) =&gt; {\n    !val &amp;&amp; props.remove();\n  }\n);\n\n// 确认\nconst _sure = () =&gt; {\n  typeof props.handleOk === &quot;function&quot; &amp;&amp; props.handleOk(&quot;组件参数&quot;);\n  pageVisible.value = false;\n};\n&lt;/script&gt;\n</code></pre></div><p>组件代码：/src/components/function/components/tipsDialog.ts</p><div class="language-"><pre><code>import { createApp } from &#39;vue&#39;;\nimport FunTipsDialog from &#39;./tipsDialog.vue&#39;\n// 使用vue3的createApp,以及mount,unmount方法创建挂载实例\n\nexport default function TipsDialog(options) {\n    // 创建一个节点，并将组件挂载上去\n    const mountNode = document.createElement(&#39;div&#39;)\n    document.body.appendChild(mountNode)\n    const app = createApp(FunTipsDialog, {\n        ...options, visible: true, remove() {\n            app.unmount(mountNode) //创建完后要进行销毁\n            document.body.removeChild(mountNode)\n        }\n    })\n    return app.mount(mountNode)\n}\n</code></pre></div><p>组件代码：/src/components/function/index.ts</p><div class="language-"><pre><code>//使用import.meta.globEager读取components文件夹的文件，以后缀名ts区分\nconst componentsList = import.meta.globEager(&quot;./components/**&quot;);\n\nlet List = {}; \nexport default function (app) {\n  Object.keys(componentsList).forEach((key) =&gt; {\n    // 筛选出ts后缀\n    if (key.split(&quot;.&quot;)[2] === &quot;ts&quot;) {\n        //赋值函数组件，后面抛出，js/ts中导入使用\n        List[`$${componentsList[key].default.name}`] =\n        componentsList[key].default;\n\n      //将函数组件定义到全局变量中，在vue中的script中通过proxy使用\n      app.config.globalProperties[`$${componentsList[key].default.name}`] =\n        componentsList[key].default;\n    }\n  });\n}\n\n//抛出函数组件，用于js/ts中使用\nexport const funComponentList = List;\n</code></pre></div><p>在main.ts中的use这个index.ts</p><div class="language-"><pre><code>import fc from &quot;@/components/function/index&quot;\napp.use(fc)\n</code></pre></div><p>在vue中使用 /src/views/Home.vue</p><div class="language-"><pre><code>&lt;a-button @click=&quot;clickOpenFunComponent&quot;&gt;这是自定义全局函数组件，点击打开&lt;/a-button&gt;\n\nimport { getCurrentInstance } from &quot;vue&quot;;\nconst { proxy } = getCurrentInstance();\nconst clickOpenFunComponent = () =&gt; {\n  proxy.$TipsDialog({\n    handleOk: (str) =&gt; {\n      console.log(&quot;点击成功，可以在此处做回调操作。&quot;+str);\n    },\n  });\n};\n</code></pre></div><p>在request.ts中使用，当调用接口成功或报错时弹出 /src/config/request.ts</p><div class="language-"><pre><code>import { funComponentList } from &quot;@/components/function/index&quot;;\n\nif (response?.status === 200) {\n    funComponentList.$TipsDialog({\n        content:&quot;在request.ts触发的函数式组件&quot;,\n        handleOk: (str) =&gt; {\n            console.log(&quot;点击成功，可以在此处做回调操作。&quot;+str);\n        }\n    });\n}\n</code></pre></div><p>项目截图：<br><a data-fancybox title="image.png" href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bd304c5249d4a9db4c79bd5ef1293e9~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bd304c5249d4a9db4c79bd5ef1293e9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p><a href="https://github.com/upJiang/jiangVue3Test" target="_blank" rel="noopener noreferrer">项目地址</a> 项目目前引入了: i18n vuex v-router less mock axios封装 ant-design（按需加载） srntry 构建分包 env ts的支持 三种封装组件的形式。赏个star~</p>',34);p.render=function(n,o,p,s,u,r){return e(),t("div",null,[a])};export default p;export{o as __pageData};
