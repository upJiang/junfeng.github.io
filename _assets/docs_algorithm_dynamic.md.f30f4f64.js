import{g as l,f as i,E as n}from"./common-d6bd45c0.js";const t='{"title":"","frontmatter":{},"relativePath":"docs/algorithm/dynamic.md","lastUpdated":1646232808402.0188}';var o={};const r=n('<p>动态规划题目的特征：</p><ul><li>要求你给出达成某个目的的<code>解法个数</code></li><li>不要求你给出每一种解法对应的具体路径</li></ul><blockquote><p>题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。</p></blockquote><p>示例：<br> 输出： 2<br> 解释： 有两种方法可以爬到楼顶。<br></p><ol><li>1 阶 + 1 阶 <br></li><li>2 阶<br></li></ol><p>我们可以知道：</p><ul><li>f(1) = 1</li><li>f(2) = 2</li><li>f(n) = f(n-1) + f(n-2)</li></ul><div class="language-"><pre><code>const climbStairs = function(n) {\n    // 初始化状态数组\n    const f = [];\n    // 初始化已知值\n    f[1] = 1;\n    f[2] = 2;\n    // 动态更新每一层楼梯对应的结果\n    for(let i = 3;i &lt;= n;i++){\n        f[i] = f[i-2] + f[i-1];\n    }\n    // 返回目标值\n    return f[n];\n};\n</code></pre></div><p>对于动态规划，优先选择这样的分析路径：</p><ul><li>递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系</li><li>结合记忆化搜索，明确状态转移方程</li><li>递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。</li></ul>',10);o.render=function(n,t,o,e,f,c){return i(),l("div",null,[r])};export default o;export{t as __pageData};
