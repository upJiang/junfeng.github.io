import{g as a,f as e,j as l,l as r}from"./common-d6bd45c0.js";const t='{"title":"合理的GC方案","frontmatter":{},"headers":[{"level":2,"title":"合理的GC方案","slug":"合理的gc方案"},{"level":3,"title":"javascript引擎基础GC方案：","slug":"javascript引擎基础gc方案："}],"relativePath":"docs/jsBase/memory.md","lastUpdated":1627825510093.4834}';var s={};const c=l("blockquote",null,[l("p",null,"什么时候触发垃圾回收？当环境达到一定数量的变量，对象时执行回收，或者达到一定的比例进行回收")],-1),i=l("h2",{id:"合理的gc方案"},[l("a",{class:"header-anchor",href:"#合理的gc方案","aria-hidden":"true"},"#"),r(" 合理的GC方案")],-1),n=l("h3",{id:"javascript引擎基础gc方案："},[l("a",{class:"header-anchor",href:"#javascript引擎基础gc方案：","aria-hidden":"true"},"#"),r(" javascript引擎基础GC方案：")],-1),d=l("p",null,"标记清除即：1.遍历所有可访问的对象；2.回收已不可访问的对象",-1),o=l("p",null,"GC的缺点，GC时需要停止响应其它操作，这时需要优化：",-1),p=l("p",null,"1.分代回收：区分临时对象以及持久对象，多回收临时对象，少回收持久对象",-1),u=l("p",null,"2.增量GC：就是每次处理一点，下次再处理一点，中断较多会带来上下文频繁切换到问题 最终方案：(对象/s) 比率时，中断执行GC的频率，simple GC更低些；如果大量对象都是长期“存活”，则分代处理优势也不大。",-1);s.render=function(l,r,t,s,h,v){return e(),a("div",null,[c,i,n,d,o,p,u])};export default s;export{t as __pageData};
