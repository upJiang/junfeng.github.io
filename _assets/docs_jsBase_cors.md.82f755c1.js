import{g as e,f as a,E as t}from"./common-d6bd45c0.js";const l='{"title":"同源策略","frontmatter":{},"headers":[{"level":2,"title":"同源策略","slug":"同源策略"},{"level":2,"title":"解决方案","slug":"解决方案"},{"level":2,"title":"预检请求","slug":"预检请求"},{"level":3,"title":"减少CORS预请求的次数","slug":"减少cors预请求的次数"}],"relativePath":"docs/jsBase/cors.md","lastUpdated":1639657876234.9243}';var o={};const i=t('<blockquote><p>跨域只存在于浏览器端,因为浏览器的同源策略产生了跨域，http默认80端口，https默认443</p></blockquote><h2 id="同源策略"><a class="header-anchor" href="#同源策略" aria-hidden="true">#</a> 同源策略</h2><ul><li>ajax同源策略: <br></li></ul><ol><li>不同源页面不能获取cookie；</li><li>不同源页面不能发起Ajax请求</li></ol><ul><li>dom同源策略： 它限制了不同源页面不能获取DOM</li></ul><h2 id="解决方案"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2><p><a data-fancybox title="image.png" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eba9cfb130a414fa7b9977bd9741676~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8eba9cfb130a414fa7b9977bd9741676~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><h2 id="预检请求"><a class="header-anchor" href="#预检请求" aria-hidden="true">#</a> 预检请求</h2><blockquote><p>在发出跨域请求时，如果是非简单请求， 浏览器会自动帮你先发出一个OPTIONS查询请求，称为预检， 用于确认目标资源是否支持跨域，允许后才发送 在简单请求必须满足两个条件：<br></p></blockquote><ol><li>使用的方法必须是（之一）：head，get，post</li><li>请求的header是： Accept， Accept-Language， Content-Language， Content-Type: 只限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ol><p>我们经常用的post+ Content-Type=application/json 也属于非简单请求，这个时候可以让服务器端设置Access-Control-Max-Age字段，这样在缓存未到期时间内，只会发起一次option请求</p><h3 id="减少cors预请求的次数"><a class="header-anchor" href="#减少cors预请求的次数" aria-hidden="true">#</a> 减少CORS预请求的次数</h3><p>方案一：发出简单请求</p><p>方案二：服务端设置Access-Control-Max-Age字段，在有效时间内浏览器无需再为同一个请求发送预检请求。但是它有局限性：只能为同一个请求缓存，无法针对整个域或者模糊匹配 URL 做缓存</p>',14);o.render=function(t,l,o,r,p,c){return a(),e("div",null,[i])};export default o;export{l as __pageData};
