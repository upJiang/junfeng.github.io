import{g as e,f as n,E as t}from"./common-d6bd45c0.js";const a='{"title":"快慢指针——删除链表的倒数第 N 个结点","frontmatter":{},"headers":[{"level":2,"title":"快慢指针——删除链表的倒数第 N 个结点","slug":"快慢指针——删除链表的倒数第-n-个结点"},{"level":3,"title":"思路：","slug":"思路："},{"level":3,"title":"快慢指针登场（快慢指针相差的距离就是 n）","slug":"快慢指针登场（快慢指针相差的距离就是-n）"},{"level":2,"title":"多指针法——链表的反转","slug":"多指针法——链表的反转"},{"level":3,"title":"局部反转一个链表","slug":"局部反转一个链表"},{"level":2,"title":"总结","slug":"总结"}],"relativePath":"docs/algorithm/chainHead.md","lastUpdated":1645871966257.5317}';var r={};const l=t('<p>链表题目中，有一类会涉及到反复的遍历。涉及反复遍历的题目，题目本身虽然不会直接跟你说“你好，我是一道需要反复遍历的题目”，但只要你尝试用常规的思路分析它，你会发现它一定涉及反复遍历；同时，涉及反复遍历的题目，还有一个更明显的特征，就是它们往往会涉及相对复杂的链表操作，比如反转、指定位置的删除等等。</p><p>解决这类问题，我们用到的是双指针中的“快慢指针”。快慢指针指的是两个一前一后的指针，两个指针往同一个方向走，只是一个快一个慢。快慢指针严格来说只能有俩，不过实际做题中，可能会出现一前、一中、一后的三个指针，这种超过两个指针的解题方法也叫“多指针法”。</p><p>快慢指针+多指针，双管齐下，可以帮助我们解决链表中的大部分复杂操作问题。</p><h2 id="快慢指针——删除链表的倒数第-n-个结点"><a class="header-anchor" href="#快慢指针——删除链表的倒数第-n-个结点" aria-hidden="true">#</a> 快慢指针——删除链表的倒数第 N 个结点</h2><blockquote><p>真题描述：给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。说明：给定的 n 保证是有效的。</p></blockquote><p>示例：<br> 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null, 和 n = 2. <br> 当删除了倒数第二个结点后，链表变为 1-&gt;2-&gt;3-&gt;5-&gt;null. <br></p><h3 id="思路："><a class="header-anchor" href="#思路：" aria-hidden="true">#</a> 思路：</h3><p>不使用快慢指针的双层循环，将倒数往后变成正数往前，并结合 dummy 结点：</p><ul><li>删除倒数的第 n 个结点，我们可以转换成正数，先遍历一遍链表获取长度 len</li><li>正数为: m = len - n + 1 ; 比如 len:7 n：2 那么我们需要删除的是：6 = 7 - 2 + 1</li><li>当遍历到 len-n 时，删除 此时的 next 即可</li><li>弊端：！两层循环</li></ul><h3 id="快慢指针登场（快慢指针相差的距离就是-n）"><a class="header-anchor" href="#快慢指针登场（快慢指针相差的距离就是-n）" aria-hidden="true">#</a> 快慢指针登场（快慢指针相差的距离就是 n）</h3><p>思路：</p><ul><li>定义两个指针：slow 和 fast，全部指向链表的起始位——dummy 结点，它们之间相差的步数（距离/结点数）就是题目中的 n</li><li>当 fast 指针走到底了 !fast.next，那么 slow 此时的位置就是题目中倒数第 n -1 的位置，此时改变 slow 的next： slow.next = slow.next.next</li></ul><div class="language-"><pre><code>const removeNthFromEnd = function(head, n) {\n    // 初始化 dummy 结点\n    const dummy = new ListNode()\n    // dummy指向头结点\n    dummy.next = head\n    // 初始化快慢指针，均指向dummy\n    let fast = dummy\n    let slow = dummy\n\n    // 快指针闷头走 n 步\n    while(n!==0){\n        fast = fast.next\n        n--\n    }\n    \n    // 快慢指针一起走\n    while(fast.next){\n        fast = fast.next\n        slow = slow.next\n    }\n    \n    // 慢指针删除自己的后继结点\n    slow.next = slow.next.next\n    // 返回头结点\n    return dummy.next\n};\n</code></pre></div><h2 id="多指针法——链表的反转"><a class="header-anchor" href="#多指针法——链表的反转" aria-hidden="true">#</a> 多指针法——链表的反转</h2><blockquote><p>完全反转一个链表: 定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p></blockquote><p>示例: <br> 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL <br> 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL <br></p><p><strong>处理链表的本质，是处理链表结点之间的指针关系。</strong><a data-fancybox title="img" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/29/171260bdb3250b83~tplv-t2oaga2asx-watermark.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/29/171260bdb3250b83~tplv-t2oaga2asx-watermark.awebp" alt="img"></a></p><p>转换成：</p><p><a data-fancybox title="img" href="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/29/171260d3c16a73ec~tplv-t2oaga2asx-watermark.awebp"><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/29/171260d3c16a73ec~tplv-t2oaga2asx-watermark.awebp" alt="img"></a></p><p>通过反转指针，就是改变cur.next = pre</p><div class="language-"><pre><code>// 反转指针\ncur.next = pre;\n// pre 往前走一步\npre = cur;\n// cur往前走一步\ncur = next;\n</code></pre></div><p>编码实现：</p><div class="language-"><pre><code>const reverseList = function(head) {\n    // 初始化前驱结点为 null\n    let pre = null;\n    // 初始化目标结点为头结点\n    let cur = head;\n    // 只要目标结点不为 null，遍历就得继续\n    while (cur !== null) {\n        // 记录一下 next 结点\n        let next = cur.next;\n        // 反转指针\n        cur.next = pre;\n        // pre 往前走一步\n        pre = cur;\n        // cur往前走一步\n        cur = next;\n    }\n    // 反转结束后，pre 就会变成新链表的头结点\n    return pre\n};\n\n// 递归实现\nconst ReverseList = function(head) \n{ \n    if(head === null || head.next === null) return head; \n\n    // 在脑海中想象一下，其实就是把下一项的 next 链子反过来指向了自己，然后把自己的 next 给删掉。\n    // 重复递归就像是一个不断把右手搭到左边的感觉,再把左边清空\n    head.next.next = head; \n    head.next = null;  \n\n    return ReverseList(head.next); \n}; \n</code></pre></div><h3 id="局部反转一个链表"><a class="header-anchor" href="#局部反转一个链表" aria-hidden="true">#</a> 局部反转一个链表</h3><blockquote><p>真题描述：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p></blockquote><p>示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4 输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p><p>思路：</p><ul><li>更上面的反转差不多，我们反转的是一个区间</li><li>当遍历到 m 时，我们需要记住这个区间起始点 m：leftHead = m；因为反转后这个 m.next 指向最后一个遍历结点的 pre</li><li>并且记住区间的第一个结点 start，因为反转后这个 start.next 要指向区间的 next</li></ul><div class="language-"><pre><code>// 入参是头结点、m、n\nconst reverseBetween = function(head, m, n) {\n    // 定义pre、cur，用leftHead来承接整个区间的前驱结点\n    let pre,cur,leftHead\n    // 别忘了用 dummy 嗷\n    const dummy = new ListNode()  \n    // dummy后继结点是头结点\n    dummy.next = head\n    // p是一个游标，用于遍历，最初指向 dummy\n    let p = dummy  \n    // p往前走 m-1 步，走到整个区间的前驱结点处\n    for(let i=0;i&lt;m-1;i++){\n        p = p.next\n    }\n    // 缓存这个前驱结点到 leftHead 里\n    leftHead = p\n    // start 是反转区间的第一个结点\n    let start = leftHead.next  \n    // pre 指向start\n    pre = start\n    // cur 指向 start 的下一个结点\n    cur = pre.next\n    // 开始重复反转动作\n    for(let i=m;i&lt;n;i++){\n        let next = cur.next\n        cur.next = pre\n        pre = cur\n        cur = next\n    }\n    //  leftHead 的后继结点此时为反转后的区间的第一个结点\n    leftHead.next = pre\n    // 将区间内反转后的最后一个结点 next 指向 cur\n    start.next=cur\n    // dummy.next 永远指向链表头结点\n    return dummy.next\n};\n</code></pre></div><h2 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>快慢指针就是通过快慢的距离差，来完成题目中倒数第几或者是间隔的问题。</p><p>多指针用来完成一些链表反转或者是局部反转问题,局部反转要考虑区间首尾的处理，记住区间第一个节点以及上一个节点用于最后一步的反转</p><div class="language-"><pre><code>cur.next = pre\npre = cur\ncur = next\n</code></pre></div><p>也可以使用递归方法实现完全反转，通过不断改变 cur.next.next = cur;cur.next = null,这么一个右手搭左边，把左边清空的感觉</p>',34);r.render=function(t,a,r,s,d,u){return n(),e("div",null,[l])};export default r;export{a as __pageData};
