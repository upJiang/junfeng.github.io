import{g as n,f as a,E as s}from"./common-d6bd45c0.js";const e='{"title":"函数家族","frontmatter":{},"headers":[{"level":2,"title":"函数家族","slug":"函数家族"},{"level":2,"title":"this 关键字的行为","slug":"this-关键字的行为"},{"level":2,"title":"剪头函数中的this","slug":"剪头函数中的this"},{"level":2,"title":"class中的this","slug":"class中的this"},{"level":2,"title":"操作 this 的内置函数","slug":"操作-this-的内置函数"},{"level":3,"title":"相似之处","slug":"相似之处"},{"level":3,"title":"区别","slug":"区别"},{"level":2,"title":"手写call,apply,bind","slug":"手写call-apply-bind"}],"relativePath":"docs/reStudy/js_function.md","lastUpdated":1639657876306.879}';var i={};const o=s('<h2 id="函数家族"><a class="header-anchor" href="#函数家族" aria-hidden="true">#</a> 函数家族</h2><h4 id="普通函数：用-function-关键字定义的函数。"><a class="header-anchor" href="#普通函数：用-function-关键字定义的函数。" aria-hidden="true">#</a> 普通函数：用 function 关键字定义的函数。</h4><div class="language-"><pre><code>function foo(){\n    // code\n}\n</code></pre></div><h4 id="箭头函数：用-运算符定义的函数。"><a class="header-anchor" href="#箭头函数：用-运算符定义的函数。" aria-hidden="true">#</a> 箭头函数：用 =&gt; 运算符定义的函数。</h4><div class="language-"><pre><code>const foo = () =&gt; {\n    // code\n}\n</code></pre></div><h4 id="方法：在-class-中定义的函数。"><a class="header-anchor" href="#方法：在-class-中定义的函数。" aria-hidden="true">#</a> 方法：在 class 中定义的函数。</h4><div class="language-"><pre><code>class C {\n    foo(){\n        //code\n    }\n}\n</code></pre></div><h4 id="类：用-class-定义的类，实际上也是函数。"><a class="header-anchor" href="#类：用-class-定义的类，实际上也是函数。" aria-hidden="true">#</a> 类：用 class 定义的类，实际上也是函数。</h4><div class="language-"><pre><code>class Foo {\n    constructor(){\n        //code\n    }\n}\n</code></pre></div><h4 id="异步函数：普通函数、箭头函数和生成器函数加上-async-关键字。"><a class="header-anchor" href="#异步函数：普通函数、箭头函数和生成器函数加上-async-关键字。" aria-hidden="true">#</a> 异步函数：普通函数、箭头函数和生成器函数加上 async 关键字。</h4><div class="language-"><pre><code>async function foo(){\n    // code\n}\nconst foo = async () =&gt; {\n    // code\n}\nasync function foo*(){\n    // code\n}\n</code></pre></div><h2 id="this-关键字的行为"><a class="header-anchor" href="#this-关键字的行为" aria-hidden="true">#</a> this 关键字的行为</h2><p>this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同</p><div class="language-"><pre><code>function showThis(){\n    console.log(this);\n}\n\nvar o = {\n    showThis: showThis\n}\n\nshowThis(); // global\no.showThis(); // o\n</code></pre></div><p><strong>调用函数时使用的引用，决定了函数执行时刻的 this 值。</strong></p><h2 id="剪头函数中的this"><a class="header-anchor" href="#剪头函数中的this" aria-hidden="true">#</a> 剪头函数中的this</h2><div class="language-"><pre><code>const showThis = () =&gt; {\n    console.log(this);\n}\n\nvar o = {\n    showThis: showThis\n}\n\nshowThis(); // global\no.showThis(); // global\n</code></pre></div><h2 id="class中的this"><a class="header-anchor" href="#class中的this" aria-hidden="true">#</a> class中的this</h2><div class="language-"><pre><code>class C {\n    showThis() {\n        console.log(this);\n    }\n}\nvar o = new C();\nvar showThis = o.showThis;\n\nshowThis(); // undefined\no.showThis(); // o\n\n等同于严格模式下：\n&quot;use strict&quot;\nfunction showThis(){\n    console.log(this);\n}\n\nvar o = {\n    showThis: showThis\n}\n\nshowThis(); // undefined\no.showThis(); // o\n</code></pre></div><h4 id="为什么输出undefined？"><a class="header-anchor" href="#为什么输出undefined？" aria-hidden="true">#</a> 为什么输出undefined？</h4><p>答：因为 class 设计成了默认按 strict 模式执行，this 严格按照调用时传入的值，可能为 null 或者 undefined。</p><p>JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。如下图所示：</p><p><a data-fancybox title="image.png" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbf75c95a4cb4dfa85e589c5f1a12381~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbf75c95a4cb4dfa85e589c5f1a12381~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a> 当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈</p><p>而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性。</p><p>[[thisMode]] 私有属性有三个取值。</p><ul><li>lexical：表示从上下文中找 this，这对应了箭头函数。</li><li>global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。</li><li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li></ul><p>函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新纪录的[[ThisBindingStatus]]私有属性。</p><p>代码执行遇到 this 时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。</p><p>这样的规则的实际效果是，嵌套的箭头函数中的代码都指向外层 this，例如：</p><div class="language-"><pre><code>var o = {}\no.foo = function foo(){\n    console.log(this);\n    return () =&gt; {\n        console.log(this);\n        return () =&gt; console.log(this);\n    }\n}\n\no.foo()()(); // o, o, o\n</code></pre></div><p>这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层都是箭头函数。这里调用三个函数，获得的 this 值是一致的，都是对象 o。</p><h2 id="操作-this-的内置函数"><a class="header-anchor" href="#操作-this-的内置函数" aria-hidden="true">#</a> 操作 this 的内置函数</h2><p>Function.prototype.call 和 Function.prototype.apply <br> 可以指定函数调用时传入的 this 值，示例如下：</p><div class="language-"><pre><code>//这里 call 和 apply 作用是一样的，只是传参方式有区别。会立即执行\nfunction foo(a, b, c){\n    console.log(this); //如果传进来的this是null或者undefined，那么将会输出global\n    console.log(a, b, c);\n}\nfoo.call({}, 1, 2, 3);\nfoo.apply({}, [1, 2, 3]);\n\n//bind\nfunction foo(a, b, c){\n    console.log(this);\n    console.log(a, b, c);\n}\nfoo.bind({}, 1, 2, 3)();\n</code></pre></div><h3 id="相似之处"><a class="header-anchor" href="#相似之处" aria-hidden="true">#</a> 相似之处</h3><p>1、都是用来改变函数的this对象的指向的。<br> 2、第一个参数都是this要指向的对象。<br> 3、都可以利用后续参数传参。</p><h3 id="区别"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h3><p>1.call、apply与bind都用于改变this绑定，但call、apply在改变this指向的同时还会执行函数，而bind在改变this后是返回一个全新的boundFcuntion绑定函数，这也是为什么上方例子中bind后还加了一对括号 ()的原因。</p><p>2.bind属于硬绑定，返回的 boundFunction 的 this 指向无法再次通过bind、apply或 call 修改；call与apply的绑定只适用当前调用，调用完就没了，下次要用还得再次绑。</p><p>3.call与apply功能完全相同，唯一不同的是call方法传递函数调用形参是以散列形式，而apply方法的形参是一个数组。在传参的情况下，call的性能要高于apply，因为apply在执行时还要多一步解析数组。</p><p>wx.say.bind(this) 不能立即执行，无效，必须wx.say.bind(this)(&quot;aaa&quot;),参数置后<br> wx.say.call(this,&quot;aaa&quot;,&quot;bbb&quot;) 立即执行<br> wx.say.apply(this,[&quot;aaa&quot;,&quot;bbb&quot;]) 立即执行,参数为数组</p><h2 id="手写call-apply-bind"><a class="header-anchor" href="#手写call-apply-bind" aria-hidden="true">#</a> 手写call,apply,bind</h2><div class="language-"><pre><code>Function.prototype.myCall = \n    function (ctx) { \n    ctx = ctx || window; \n    ctx.fn = this; \n    let args = Array.from(arguments).slice(1); \n    let res = ctx.fn(...args); \n    delete ctx.fn; \n    return res;\n}; \nFunction.prototype.myApply = function (ctx) { \n    ctx = ctx || window; \n    ctx.fn = this; \n    let args = Array.from(arguments[1]); \n    let res = ctx.fn(...args); \n    delete ctx.fn; \n    return res; \n};\nFunction.prototype.myBind = function (ctx) { \n    let args = Array.from(arguments).slice(1); \n    let that = this; \n    return function (...oargs) \n        { \n            return that.apply(ctx, [...args, ...oargs]); \n        };\n };\n</code></pre></div>',43);i.render=function(s,e,i,t,l,c){return a(),n("div",null,[o])};export default i;export{e as __pageData};
