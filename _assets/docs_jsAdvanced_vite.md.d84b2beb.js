import{g as e,f as t,E as n}from"./common-d6bd45c0.js";const o='{"title":"概念","frontmatter":{},"headers":[{"level":2,"title":"概念","slug":"概念"},{"level":2,"title":"实现步骤","slug":"实现步骤"},{"level":2,"title":"在vue中的文件执行顺序","slug":"在vue中的文件执行顺序"},{"level":2,"title":"热更新原理","slug":"热更新原理"},{"level":2,"title":"服务端原理","slug":"服务端原理"},{"level":2,"title":"客户端原理","slug":"客户端原理"},{"level":2,"title":"简单vite代码实现","slug":"简单vite代码实现"},{"level":2,"title":"vite在使用中的问题","slug":"vite在使用中的问题"},{"level":2,"title":"vite插件","slug":"vite插件"}],"relativePath":"docs/jsAdvanced/vite.md","lastUpdated":1639657876219.9275}';var r={};const i=n('<h2 id="概念"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><blockquote><p>基于esm（浏览器原生es Module的支持）</p></blockquote><ol><li>Vite，一个基于浏览器原生ES模块的开发服务器。利用浏览器去解析模块，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时另有有Vue文件支持，还搞定了热更新，而且热更新的速度不会随着模块增加而变慢。</li><li>Vite要求项目完全由ES模块模块组成，common.js模块不能直接在Vite上使用。因此不能直接在生产环境中使用。在打包上依旧还是使用rollup等传统打包工具。</li><li>Vite的基本实现原理，就是启动一个koa服务器拦截浏览器请求ES模块的请求。通过路径查找目录下对应文件的文件做一定的处理最终以ES模块格式返回给客户端</li></ol><h2 id="实现步骤"><a class="header-anchor" href="#实现步骤" aria-hidden="true">#</a> 实现步骤</h2><p>首先启动一个koa服务器，对首页(index.html)、js文件、裸模块比如&quot;vue&quot;、vue文件等进行分别处理<br></p><ol><li>先返回index.html,然后再index.html中去加载main.js,在main.js中再去加载其它文件</li><li>加载main.js中的裸模块，比如&quot;vue&quot;,vite会通过预打包，将vue模块的内容打包到node_modules中，然后替换路径 <br> import {createApp} from &#39;vue&#39; 转换成 import {createApp} from &#39;/@modules/vue&#39;<br> 通过 /@modules标识去node_module中查找并返回相对地址<br></li><li>加载vue文件，当Vite遇到一个.vue后缀的文件时使用vue中的compiler方法进行解析并返回。<br> 由于.vue模板文件的特殊性，它被分割成三个模块（template，css，脚本模块）进行分别处理。最后放入script，template，css发送多个请求获取。</li></ol><h2 id="在vue中的文件执行顺序"><a class="header-anchor" href="#在vue中的文件执行顺序" aria-hidden="true">#</a> 在vue中的文件执行顺序</h2><p>localhost ==》 client(websocket) ==&gt; main.js ==&gt; env.js ==&gt; vue.js(裸模块vue) ==&gt; app.vue ==&gt; 最后就是执行里面的路由，组件，ui库等</p><h2 id="热更新原理"><a class="header-anchor" href="#热更新原理" aria-hidden="true">#</a> 热更新原理</h2><p>Vite的热加载原理，实际上就是在客户端与服务端建立了一个websocket链接，当代码被修改时，服务端发送消息通知客户端去请求修改模块的代码，完成热更新。<br> 查看network,在localhost后会执行client文件，就是在这里建立webcocket实现热更新，然后再进入main.js</p><h2 id="服务端原理"><a class="header-anchor" href="#服务端原理" aria-hidden="true">#</a> 服务端原理</h2><p>服务端做的就是监听代码文件的更改，在适当的时机向客户端发送websocket信息通知客户端去请求新的模块代码。</p><h2 id="客户端原理"><a class="header-anchor" href="#客户端原理" aria-hidden="true">#</a> 客户端原理</h2><p>Vite的websocket相关代码在处理html中时被编写代码中</p><h2 id="简单vite代码实现"><a class="header-anchor" href="#简单vite代码实现" aria-hidden="true">#</a> 简单vite代码实现</h2><p>/src/app.vue</p><div class="language-"><pre><code>&lt;template&gt;\n  &lt;div&gt;{{ title }}&lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport { ref } from &quot;vue&quot;;\nexport default {\n  setup() {\n    const title = ref(&quot;hello, kvite!&quot;);\n    return { title };\n  },\n};\n&lt;/script&gt;\n</code></pre></div><p>src/main.js</p><div class="language-"><pre><code>import {createApp} from &#39;vue&#39;\nimport App from &quot;./app.vue&quot;\n\ncreateApp(App).mount(&#39;#app&#39;)\n</code></pre></div><p>index.html</p><div class="language-"><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;title&gt;kvite&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n        window.process = {\n            env:{\n                NODE_ENV:&#39;dev&#39;\n            }\n        }\n    &lt;/script&gt;\n    &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre></div><p>kvite.js</p><div class="language-"><pre><code>const Koa = require(&#39;koa&#39;)\nconst app = new Koa()\n\nconst opn = require(&#39;opn&#39;);\nconst fs = require(&quot;fs&quot;)\nconst path = require(&quot;path&quot;)\nconst complierSFC = require(&#39;@vue/compiler-sfc&#39;) //引入vue文件的解析\nconst complierDOM = require(&#39;@vue/compiler-dom&#39;) //引入template的解析\n\n// 中间件配置\n// 处理路由\napp.use(async (ctx) =&gt; {\n  const {\n    url,\n    query\n  } = ctx.request\n\n  // 首页请求\n  if (url === &#39;/&#39;) {\n    //加载index.html\n    ctx.type = &quot;text/html&quot;;\n    ctx.body = fs.readFileSync(path.join(__dirname, &quot;./index.html&quot;), &quot;utf8&quot;);\n  } else if (url.endsWith(&#39;.js&#39;)) {\n    // js文件加载处理\n    const p = path.join(__dirname, url)\n    ctx.type = &#39;application/javascript&#39;\n    ctx.body = rewriteImport(fs.readFileSync(p, &#39;utf8&#39;))\n  } else if (url.startsWith(&quot;/@modules/&quot;)) {\n    //裸模块名称\n    const moduleName = url.replace(&quot;/@modules/&quot;, &quot;&quot;);\n    //去node_modules目录中找\n    const prefix = path.join(__dirname, &quot;./node_modules&quot;, moduleName);\n    //package.json中获取module字段\n    const module = require(prefix + &quot;/package.json&quot;).module;\n    const filePath = path.join(prefix, module);\n    const ret = fs.readFileSync(filePath, &quot;utf8&quot;);\n    ctx.type = &#39;application/javascript&#39;\n    ctx.body = rewriteImport(ret)\n  } else if (url.indexOf(&#39;.vue&#39;) &gt; -1) {\n    //获取加载文件路径\n    const p = path.join(__dirname, url.split(&quot;?&quot;)[0]);\n    const ret = complierSFC.parse(fs.readFileSync(p, &#39;utf8&#39;)); // console.log(ret)  可以看到是一颗ast树，可以在终端中查看\n    if (!query.type) {\n      //SFC请求，读取vue文件，解析为js\n      //获取脚本部分的内容\n      const scriptContent = ret.descriptor.script.content;\n      //替换默认导出为一个常量，方便后续修改\n      const script = scriptContent.replace(\n        &quot;export default &quot;,\n        &quot;const __script = &quot;\n      );\n      ctx.type = &#39;application/javascript&#39;\n      ctx.body = `\n        ${rewriteImport(script)}\n        // 解析template\n        import {render as __render} from &#39;${url}?type=template&#39;\n        __script.render = __render\n        export default __script\n        `;\n    } else if (query.type === &quot;template&quot;) {\n      const tpl = ret.descriptor.template.content;\n      //编译为render\n      const render = complierDOM.compile(tpl, {\n        mode: &quot;module&quot;\n      }).code;\n      ctx.type = &#39;application/javascript&#39;\n      ctx.body = rewriteImport(render)\n    }\n  }\n})\n\n// 裸模块地址的重写\n//在vite中对于vue这种裸模块是无法识别的，它通过预编译把需要的模块打包到node_modules中，再通过相对地址找到并加载，\n//这里我们通过识别 /@modules 这种地址标识，去找寻模块，进行地址的替换\n//import xx from &quot;vue&quot;  ==&gt; import xx from &quot;/@modules/vue&quot;\nfunction rewriteImport(content) {\n  return content.replace(/ from [&#39;&quot;](.*)[&#39;&quot;]/g, function (s1, s2) {\n    if (s2.startsWith(&quot;./&quot;) || s2.startsWith(&quot;/&quot;) || s2.startsWith(&quot;../&quot;)) {\n      return s1\n    } else {\n      //裸模块替换\n      return ` from &#39;/@modules/${s2}&#39;`\n    }\n  })\n}\n\napp.listen(6666, () =&gt; {\n  console.log(&#39;kvite start&#39;);\n  opn(`http://localhost:6666/`);\n})\n</code></pre></div><p><a href="https://github.com/upJiang/kvite" target="_blank" rel="noopener noreferrer">代码地址</a></p><p><a href="https://www.bilibili.com/video/BV1dh411S7Vz" target="_blank" rel="noopener noreferrer">vite工作原理和手写实现视频地址</a></p><h2 id="vite在使用中的问题"><a class="header-anchor" href="#vite在使用中的问题" aria-hidden="true">#</a> vite在使用中的问题</h2><p>qs对vite打包后好像不兼容 ，最后使用qs-stringfy</p><p>require模块不能使用，需要使用import.meta.glob</p><h2 id="vite插件"><a class="header-anchor" href="#vite插件" aria-hidden="true">#</a> vite插件</h2><p><a data-fancybox title="image.png" href="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c0f005acb754a7eb2e8caaaabb145d9~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c0f005acb754a7eb2e8caaaabb145d9~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p><a data-fancybox title="image.png" href="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa4aedf1a52749c19fa7f08575896218~tplv-k3u1fbpfcp-watermark.image?"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa4aedf1a52749c19fa7f08575896218~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></a></p><p>插件案例</p><div class="language-"><pre><code>/plugins/vite-plugin-my-example.ts\n\nexport default function myExample () {\n    // 返回的是插件对象\n    return {\n      name: &#39;my-example&#39;, // 名称用于警告和错误展示\n      // enforce: &#39;pre&#39;|&#39;post&#39;\n      // 初始化hooks，只走一次\n      options(opts) {\n        console.log(&#39;options&#39;, opts);\n      },\n      buildStart() {\n        console.log(&#39;buildStart&#39;);\n      },\n      config(config) {\n        console.log(&#39;config&#39;, config);\n        return {}\n      },\n      configResolved(resolvedCofnig) {\n        console.log(&#39;configResolved&#39;);\n      },\n      configureServer(server) {\n        console.log(&#39;configureServer&#39;);\n        // server.app.use((req, res, next) =&gt; {\n        //   // custom handle request...\n        // })\n      },\n      transformIndexHtml(html) {\n        console.log(&#39;transformIndexHtml&#39;);\n        return html\n        // return html.replace(\n        //   /&lt;title&gt;(.*?)&lt;\\/title&gt;/,\n        //   `&lt;title&gt;Title replaced!&lt;/title&gt;`\n        // )\n      },\n      // id确认\n      resolveId ( source ) {\n        if (source === &#39;virtual-module&#39;) {\n          console.log(&#39;resolvedId&#39;, source);\n          return source; // 返回source表明命中，vite不再询问其他插件处理该id请求\n        }\n        return null; // 返回null表明是其他id要继续处理\n      },\n      // 加载模块代码\n      load ( id ) {\n        if (id === &#39;virtual-module&#39;) {\n          console.log(&#39;load&#39;);\n          return &#39;export default &quot;This is virtual!&quot;&#39;; // 返回&quot;virtual-module&quot;模块源码\n        }\n        return null; // 其他id继续处理\n      },\n      // 转换\n      transform(code, id) {\n        if (id === &#39;virtual-module&#39;) {\n          console.log(&#39;transform&#39;);\n        }\n        return code\n      },\n    };\n  }\n</code></pre></div><div class="language-"><pre><code>vite.config.ts\n\nimport myExample from &#39;./plugins/vite-plugin-my-example&#39;  //自定义插件\n\nexport default defineConfig({\n  plugins: [vue(),\n  myExample()\n  ], //插件\n})\n\n//在项目运行时，可以看到插件钩子的执行\n</code></pre></div><p><a href="https://www.bilibili.com/video/BV1jb4y1R7UV" target="_blank" rel="noopener noreferrer">vite插件开发指南视频地址</a></p><p><a href="https://vitejs.dev/" target="_blank" rel="noopener noreferrer">vitejs官网地址</a></p>',36);r.render=function(n,o,r,l,a,p){return t(),e("div",null,[i])};export default r;export{o as __pageData};
